<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Pan</title>
  
  <subtitle>Jack Pan的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jack0pan.github.io/"/>
  <updated>2018-05-04T14:33:00.420Z</updated>
  <id>http://jack0pan.github.io/</id>
  
  <author>
    <name>Jack Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Construct Binary Tree from Traversal</title>
    <link href="http://jack0pan.github.io/2018/05/04/Construct-Binary-Tree-from-Traversal/"/>
    <id>http://jack0pan.github.io/2018/05/04/Construct-Binary-Tree-from-Traversal/</id>
    <published>2018-05-04T14:31:49.000Z</published>
    <updated>2018-05-04T14:33:00.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Construct-Binary-Tree-from-Traversal"><a href="#Construct-Binary-Tree-from-Traversal" class="headerlink" title="Construct Binary Tree from Traversal"></a>Construct Binary Tree from Traversal</h1><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure></p><p>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>通过前序遍历数组我们可以知道第一个元素为根节点，然后去中序遍历中找到该元素，它左边的为左子树，右边的为右子树。这样递归遍历两个数组即可得到二叉树。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; preorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; inorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(preorder, inorder)</span></span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  inorder.each_with_index <span class="keyword">do</span> <span class="params">|v, i|</span></span><br><span class="line">    hash[v] = i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  _build_tree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _build_tree<span class="params">(preorder, pre_left, pre_right, inorder, in_left, in_right, hash)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> pre_left &gt; pre_right <span class="keyword">or</span> in_left &gt; in_right</span><br><span class="line">  root = TreeNode.new(preorder[pre_left])</span><br><span class="line">  delta = hash[root.val] - in_left</span><br><span class="line">  root.left = _build_tree(preorder, pre_left + <span class="number">1</span>, pre_left + delta, inorder, in_left, hash[root.val] - <span class="number">1</span>, hash)</span><br><span class="line">  root.right = _build_tree(preorder, pre_left + delta + <span class="number">1</span>, pre_right, inorder, hash[root.val] + <span class="number">1</span>, in_right, hash)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure></p><p>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>通过后序遍历数组我们可以知道最后一个元素为根节点，然后去中序遍历中找到该元素，它左边的为左子树，右边的为右子树。这样递归遍历两个数组即可得到二叉树。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; inorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; postorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(inorder, postorder)</span></span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  inorder.each_with_index <span class="keyword">do</span> <span class="params">|v, i|</span></span><br><span class="line">    hash[v] = i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  _build_tree(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _build_tree<span class="params">(postorder, post_left, post_right, inorder, in_left, in_right, hash)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> post_left &gt; post_right <span class="keyword">or</span> in_left &gt; in_right</span><br><span class="line">  root = TreeNode.new(postorder[post_right])</span><br><span class="line">  delta = hash[root.val] - in_left</span><br><span class="line">  root.left = _build_tree(postorder, post_left, post_left + delta - <span class="number">1</span>, inorder, in_left, hash[root.val] - <span class="number">1</span>, hash)</span><br><span class="line">  root.right = _build_tree(postorder, post_left + delta, post_right - <span class="number">1</span>, inorder, hash[root.val] + <span class="number">1</span>, in_right, hash)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Construct-Binary-Tree-from-Traversal&quot;&gt;&lt;a href=&quot;#Construct-Binary-Tree-from-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Construct Binary Tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="http://jack0pan.github.io/2018/05/04/Binary-Tree-Level-Order-Traversal/"/>
    <id>http://jack0pan.github.io/2018/05/04/Binary-Tree-Level-Order-Traversal/</id>
    <published>2018-05-04T13:57:18.000Z</published>
    <updated>2018-05-04T14:29:10.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h1><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>二叉树的广度优先遍历。遍历当前层的同时，把子节点放入队列中，这样一层一层遍历，直到队列为空。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result &lt;&lt; level</span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. Binary Tree Level Order Traversal II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its bottom-up level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这题和<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">前面题</a>一样，只需把最后结构逆序即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_bottom</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result &lt;&lt; level</span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result.reverse</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its zigzag level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>这题在<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>基础上，加个标记，偶数行做一下反转即可。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzag_level_order</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  reverse = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> reverse</span><br><span class="line">      result &lt;&lt; level.reverse</span><br><span class="line">      reverse = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result &lt;&lt; level</span><br><span class="line">      reverse = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Level-Order-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Level-Order-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Level Order Tr
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Unique Binary Search Trees</title>
    <link href="http://jack0pan.github.io/2018/05/03/Unique-Binary-Search-Trees/"/>
    <id>http://jack0pan.github.io/2018/05/03/Unique-Binary-Search-Trees/</id>
    <published>2018-05-03T13:44:32.000Z</published>
    <updated>2018-05-03T14:35:34.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h1><h2 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>解决思路就是以任意一个数为根，比它小的数为左子树，大的为右子树，二叉搜索树的数量就是左子树数量乘以右子树的数量，总数就是以每个数为根节点的二叉搜索树的总和。</p><p>总结成公式为：<br><img src="http://junzhepanblog.qiniudn.com/unique-binary-search-trees/catalan.png" alt="卡特兰数"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_trees</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">  result = Array.new(n + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  result[<span class="number">0</span>], result[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>..n).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    i.times.each <span class="keyword">do</span> <span class="params">|j|</span></span><br><span class="line">      result[i] += result[j] * result[i - j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result[n]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="95-Unique-Binary-Search-Trees"><a href="#95-Unique-Binary-Search-Trees" class="headerlink" title="95. Unique Binary Search Trees"></a>95. Unique Binary Search Trees</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>思路跟<a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Unique Binary Search Trees</a>的类似。</p><ul><li>每选一个节点为根，就要递归求解左右子树的所有情况。</li><li>遍历左右子树的所有情况，把当前节点和左右子树拼接起来。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_trees</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">  _generate_trees(<span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _generate_trees<span class="params">(left, right)</span></span></span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">if</span> left &gt; right</span><br><span class="line">    result &lt;&lt; <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    (left..right).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      lefts = _generate_trees(left, i - <span class="number">1</span>)</span><br><span class="line">      rights = _generate_trees(i + <span class="number">1</span>, right)</span><br><span class="line">      lefts.length.times.each <span class="keyword">do</span> <span class="params">|j|</span></span><br><span class="line">        rights.length.times.each <span class="keyword">do</span> <span class="params">|k|</span></span><br><span class="line">          root = TreeNode.new(i)</span><br><span class="line">          root.left = lefts[j]</span><br><span class="line">          root.right = rights[k]</span><br><span class="line">          result &lt;&lt; root</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unique-Binary-Search-Trees&quot;&gt;&lt;a href=&quot;#Unique-Binary-Search-Trees&quot; class=&quot;headerlink&quot; title=&quot;Unique Binary Search Trees&quot;&gt;&lt;/a&gt;Unique B
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Deep Traversal</title>
    <link href="http://jack0pan.github.io/2018/04/28/Binary-Tree-Deep-Traversal/"/>
    <id>http://jack0pan.github.io/2018/04/28/Binary-Tree-Deep-Traversal/</id>
    <published>2018-04-28T15:06:25.000Z</published>
    <updated>2018-05-05T02:38:49.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Deep-Traversal"><a href="#Binary-Tree-Deep-Traversal" class="headerlink" title="Binary Tree Deep Traversal"></a>Binary Tree Deep Traversal</h1><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>二叉树中序遍历，题目要求迭代方式实现。</p><p>先来看递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>再看迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">or</span> <span class="keyword">not</span> stack.empty?</span><br><span class="line">    <span class="keyword">while</span> node</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    node = stack.pop</span><br><span class="line">    path &lt;&lt; node.val</span><br><span class="line">    node = node.right</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>二叉树前序遍历</p><p>递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">or</span> <span class="keyword">not</span> stack.empty?</span><br><span class="line">    <span class="keyword">while</span> node</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    node = stack.pop</span><br><span class="line">    node = node.right</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>二叉树后序遍历</p><p>递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> stack.empty? <span class="keyword">or</span> path.empty?</span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left ? node.left : node.right</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      next_node = stack.pop </span><br><span class="line">      node = stack.last </span><br><span class="line">      <span class="keyword">while</span> node &amp;&amp; node.right == next_node</span><br><span class="line">        path &lt;&lt; next_node.val </span><br><span class="line">        next_node = stack.pop </span><br><span class="line">        node = stack.last </span><br><span class="line">      <span class="keyword">end</span> </span><br><span class="line">      node = node ? node.right : <span class="literal">nil</span></span><br><span class="line">      path &lt;&lt; next_node.val</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Deep-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Deep-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Deep Traversal&quot;&gt;&lt;/a&gt;Binary T
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Validate Binary Search Tree</title>
    <link href="http://jack0pan.github.io/2018/04/28/Validate-Binary-Search-Tree/"/>
    <id>http://jack0pan.github.io/2018/04/28/Validate-Binary-Search-Tree/</id>
    <published>2018-04-28T13:47:19.000Z</published>
    <updated>2018-05-05T02:47:39.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value</span><br><span class="line">             is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>验证一棵二叉树是否为二叉搜索树。</p><p>思路就是递归验证左子树和右子树是否都满足条件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Boolean&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_bst</span><span class="params">(root, l = <span class="literal">nil</span>, r = <span class="literal">nil</span>)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> l &amp;&amp; l &gt; root.val</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> r &amp;&amp; r &lt; root.val</span><br><span class="line"></span><br><span class="line">  is_valid_bst(root.left, l, root.val - <span class="number">1</span>) &amp;&amp; is_valid_bst(root.right, root.val + <span class="number">1</span>, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(logn)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;98-Validate-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#98-Validate-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;98. Validate Binary Search Tree&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Restore IP Addresses</title>
    <link href="http://jack0pan.github.io/2018/04/27/Restore-IP-Addresses/"/>
    <id>http://jack0pan.github.io/2018/04/27/Restore-IP-Addresses/</id>
    <published>2018-04-27T14:01:17.000Z</published>
    <updated>2018-05-05T02:31:44.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这题思路主要是用动态规划，没什么好说的。主要在于对IP的每一项的判断要筛掉以下情况：</p><ul><li>每一项的值不能大于255</li><li>不能以“0”开头（比如：01，00），这种可以通过先转成整数，再转成字符串，和原来比较是否相同。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restore_ip_addresses</span><span class="params">(s)</span></span></span><br><span class="line">  ips = []</span><br><span class="line">  ip = []</span><br><span class="line">  _restore(ips, ip, s, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> ips</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _restore<span class="params">(ips, ip, s, level)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> s.<span class="literal">nil</span>? <span class="keyword">or</span> s.empty?</span><br><span class="line">  <span class="keyword">if</span> level == <span class="number">4</span></span><br><span class="line">    p = s.to_i</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> p &gt; <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> p.to_s != s</span><br><span class="line">    ip.push(s)</span><br><span class="line">    ips.push(ip.join(<span class="string">'.'</span>))</span><br><span class="line">    ip.pop</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">3</span>.times.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> s.length &lt; (i + <span class="number">1</span>)</span><br><span class="line">      p = s[<span class="number">0</span>..i].to_i</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> p &gt; <span class="number">255</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> p.to_s != s[<span class="number">0</span>..i]</span><br><span class="line">      ip.push(s[<span class="number">0</span>..i])</span><br><span class="line">      _restore(ips, ip, s[(i+<span class="number">1</span>)..-<span class="number">1</span>], level + <span class="number">1</span>)</span><br><span class="line">      ip.pop</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>这题的时间和空间复杂度是固定的，都是<code>O(3^4)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;93-Restore-IP-Addresses&quot;&gt;&lt;a href=&quot;#93-Restore-IP-Addresses&quot; class=&quot;headerlink&quot; title=&quot;93. Restore IP Addresses&quot;&gt;&lt;/a&gt;93. Restore IP A
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="http://jack0pan.github.io/2018/04/26/Reverse-Linked-List/"/>
    <id>http://jack0pan.github.io/2018/04/26/Reverse-Linked-List/</id>
    <published>2018-04-26T13:44:32.000Z</published>
    <updated>2018-05-05T03:29:43.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h1><h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Reverse a singly linked list.</p><p>Hint:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>题目要求两种实现思路：迭代方式和递归方式。</p><h4 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h4><p>先创建一个临时节点，从头往后遍历链表，来一个节点就插入临时节点和第一个节点之间，这样遍历完后，链表就逆序了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iteratively implement</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span></span></span><br><span class="line">  dummy_head = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  p = head</span><br><span class="line">  <span class="keyword">while</span> p</span><br><span class="line">    n = p.<span class="keyword">next</span></span><br><span class="line">    p.<span class="keyword">next</span> = dummy_head.<span class="keyword">next</span></span><br><span class="line">    dummy_head.<span class="keyword">next</span> = p</span><br><span class="line">    p = n</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  dummy_head.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><p>递归结束条件是遍历到最后一个节点，直接返回。其他情况就是让下一个节点指向当前节点。中间要一直返回最后一个节点，递归完后，最后一个节点就变成第一个节点了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># recursively implement</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span></span></span><br><span class="line">  <span class="keyword">if</span> head.<span class="literal">nil</span>? <span class="keyword">or</span> head.<span class="keyword">next</span>.<span class="literal">nil</span>?</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    n = head.<span class="keyword">next</span></span><br><span class="line">    head.<span class="keyword">next</span> = <span class="literal">nil</span></span><br><span class="line">    rest = reverse_list(n)</span><br><span class="line">    n.<span class="keyword">next</span> = head</span><br><span class="line">    <span class="keyword">return</span> rest</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Reverse a linked list from position m to n. Do it in one-pass.</p><p>Note: 1 ≤ m ≤ n ≤ length of list.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这题解法就是，先找到m节点的位置，然后把m和n之间的节点插入m节点和它之前节点就行。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; m</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_between</span><span class="params">(head, m, n)</span></span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> head.<span class="literal">nil</span>?</span><br><span class="line">  dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  dummy.<span class="keyword">next</span> = head</span><br><span class="line">  m_prev, i = dummy, <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> m_prev.<span class="keyword">next</span></span><br><span class="line">    m_prev = m_prev.<span class="keyword">next</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> i &lt; m</span><br><span class="line">  m_node = m_prev.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> m_node.<span class="literal">nil</span>?</span><br><span class="line">  c_node = m_node.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> c_node</span><br><span class="line">    t = c_node.<span class="keyword">next</span></span><br><span class="line">    c_node.<span class="keyword">next</span> = m_prev.<span class="keyword">next</span></span><br><span class="line">    m_prev.<span class="keyword">next</span> = c_node</span><br><span class="line">    c_node = t</span><br><span class="line">    m_node.<span class="keyword">next</span> = c_node</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Linked List&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Decode Ways</title>
    <link href="http://jack0pan.github.io/2018/04/25/Decode-Ways/"/>
    <id>http://jack0pan.github.io/2018/04/25/Decode-Ways/</id>
    <published>2018-04-25T14:06:22.000Z</published>
    <updated>2018-05-06T03:35:25.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h1><h2 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure></p><p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们用<code>dp[i]</code>表示以第i个数字结尾的子串编码数量，计算公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] += dp[i-1] 如果s[i-1] &gt; 0</span><br><span class="line">dp[i] += dp[i-2] 如果10 &lt;= s[i-2]s[i-1] &lt;= 26</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_decodings</span><span class="params">(s)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> s.<span class="literal">nil</span>? <span class="keyword">or</span> s.empty? <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span></span><br><span class="line">  dp = Array.new(s.length + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>..s.length).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    dp[i] += dp[i - <span class="number">1</span>] <span class="keyword">if</span> s[i - <span class="number">1</span>].to_i &gt; <span class="number">0</span></span><br><span class="line">    dp[i] += dp[i - <span class="number">2</span>] <span class="keyword">if</span> s[i - <span class="number">2</span>.. i - <span class="number">1</span>].to_i &gt;= <span class="number">10</span> <span class="keyword">and</span> s[i - <span class="number">2</span>.. i - <span class="number">1</span>].to_i &lt;= <span class="number">26</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  dp[s.length]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Decode-Ways&quot;&gt;&lt;a href=&quot;#Decode-Ways&quot; class=&quot;headerlink&quot; title=&quot;Decode Ways&quot;&gt;&lt;/a&gt;Decode Ways&lt;/h1&gt;&lt;h2 id=&quot;91-Decode-Ways&quot;&gt;&lt;a href=&quot;#91-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Subsets</title>
    <link href="http://jack0pan.github.io/2018/04/24/Subsets/"/>
    <id>http://jack0pan.github.io/2018/04/24/Subsets/</id>
    <published>2018-04-24T13:56:24.000Z</published>
    <updated>2018-05-06T03:37:25.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h1><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>利用深度优先算法，把所有组合情况都遍历一遍。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  path, result = [], []</span><br><span class="line">  _subsets(nums, <span class="number">0</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _subsets<span class="params">(nums, index, path, result)</span></span></span><br><span class="line">  result.push(path.dup)</span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length</span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    _subsets(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">    path.pop</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul><h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这道题和<a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Subsets</a>的区别在于去掉重复元素，最直接的办法就是在添加一种新组合前，判断一下是否已经含有这种组合。但是，这种做法增加了时间复杂度，LeetCode上的运行时间是<code>100ms</code>。</p><p>还有一种更有效的办法，在把元素添加到组合中，直接跳过重复元素。这种做法可以把时间缩短到<code>40ms</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets_with_dup</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  path, result = [], []</span><br><span class="line">  _subsets(nums, <span class="number">0</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _subsets<span class="params">(nums, index, path, result)</span></span></span><br><span class="line">  result.push(path.dup)</span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length</span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    _subsets(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">    path.pop</span><br><span class="line">    i += <span class="number">1</span> <span class="keyword">while</span> i &lt; nums.length - <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Subsets&quot;&gt;&lt;a href=&quot;#Subsets&quot; class=&quot;headerlink&quot; title=&quot;Subsets&quot;&gt;&lt;/a&gt;Subsets&lt;/h1&gt;&lt;h2 id=&quot;78-Subsets&quot;&gt;&lt;a href=&quot;#78-Subsets&quot; class=&quot;head
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Gray Code</title>
    <link href="http://jack0pan.github.io/2018/04/23/Gray-Code/"/>
    <id>http://jack0pan.github.io/2018/04/23/Gray-Code/</id>
    <published>2018-04-23T14:01:20.000Z</published>
    <updated>2018-05-12T14:57:40.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure></p><p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p><p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p><p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>题目让生成格雷码，要生成n的格雷码，总共有2的n次方个，第i个生成方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &gt;&gt; 1) ^ i</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray_code</span><span class="params">(n)</span></span></span><br><span class="line">  i, total, result = <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n, []</span><br><span class="line">  total.times.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    result.push((i <span class="meta">&gt;&gt; </span><span class="number">1</span>) ^ i)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(2^n)</code></li><li>空间复杂度：<code>O(2^n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;89-Gray-Code&quot;&gt;&lt;a href=&quot;#89-Gray-Code&quot; class=&quot;headerlink&quot; title=&quot;89. Gray Code&quot;&gt;&lt;/a&gt;89. Gray Code&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Partition List</title>
    <link href="http://jack0pan.github.io/2018/04/20/Partition-List/"/>
    <id>http://jack0pan.github.io/2018/04/20/Partition-List/</id>
    <published>2018-04-20T14:05:10.000Z</published>
    <updated>2018-05-14T15:37:25.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>方法就是从头到尾遍历链表，把小于给定值的节点从当前链表摘除，添加到新链表中。然后把链表添加到新链表尾部即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(head, x)</span></span></span><br><span class="line">  dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  new_dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  dummy.<span class="keyword">next</span> = head</span><br><span class="line">  cur, new_cur = dummy, new_dummy</span><br><span class="line">  <span class="keyword">while</span> cur.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">if</span> cur.<span class="keyword">next</span>.val &lt; x</span><br><span class="line">      new_cur.<span class="keyword">next</span> = cur.<span class="keyword">next</span></span><br><span class="line">      new_cur = new_cur.<span class="keyword">next</span></span><br><span class="line">      cur.<span class="keyword">next</span> = cur.<span class="keyword">next</span>.<span class="keyword">next</span></span><br><span class="line">      new_cur.<span class="keyword">next</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cur = cur.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  new_cur.<span class="keyword">next</span> = dummy.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">return</span> new_dummy.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;86-Partition-List&quot;&gt;&lt;a href=&quot;#86-Partition-List&quot; class=&quot;headerlink&quot; title=&quot;86. Partition List&quot;&gt;&lt;/a&gt;86. Partition List&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Combinations</title>
    <link href="http://jack0pan.github.io/2018/04/08/Combinations/"/>
    <id>http://jack0pan.github.io/2018/04/08/Combinations/</id>
    <published>2018-04-08T14:11:33.000Z</published>
    <updated>2018-05-16T15:20:50.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这题没啥好解释的，用深度优先搜索来解就行了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; k</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(n, k)</span></span></span><br><span class="line">  path, result = [], []</span><br><span class="line">  _combine(n, k, <span class="number">1</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _combine<span class="params">(n, k, start, path, result)</span></span></span><br><span class="line">  <span class="keyword">if</span> path.size == k</span><br><span class="line">    new_path = path.dup</span><br><span class="line">    result.push(new_path)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = start</span><br><span class="line">    <span class="keyword">while</span> i &lt;= n</span><br><span class="line">      path.push(i);</span><br><span class="line">      _combine(n, k, i + <span class="number">1</span>, path, result)</span><br><span class="line">      path.pop</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;77-Combinations&quot;&gt;&lt;a href=&quot;#77-Combinations&quot; class=&quot;headerlink&quot; title=&quot;77. Combinations&quot;&gt;&lt;/a&gt;77. Combinations&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Number</title>
    <link href="http://jack0pan.github.io/2018/03/03/Palindrome-Number/"/>
    <id>http://jack0pan.github.io/2018/03/03/Palindrome-Number/</id>
    <published>2018-03-03T14:01:03.000Z</published>
    <updated>2018-08-19T12:25:49.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>Coud you solve it without converting the integer to a string?</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>思路是把给的数分成两半，判断两半是否相等。会有两种情况：</p><ul><li>数字位数是偶数，判断两部分是否相等</li><li>数字位数是奇数，将数值大的一半除以10后比较</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Boolean&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>)</span><br><span class="line">  r = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> x &gt; r</span><br><span class="line">    x, mod = x.divmod(<span class="number">10</span>)</span><br><span class="line">    r = r * <span class="number">10</span> + mod</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  x == r <span class="keyword">or</span> x == r / <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)，n是数字的位数</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9-Palindrome-Number&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number&quot;&gt;&lt;/a&gt;9. Palindrome Number&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>ZigZag Conversion</title>
    <link href="http://jack0pan.github.io/2018/03/02/ZigZag-Conversion/"/>
    <id>http://jack0pan.github.io/2018/03/02/ZigZag-Conversion/</id>
    <published>2018-03-02T14:02:47.000Z</published>
    <updated>2018-05-30T14:23:53.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我们先看一个具体的例子来找规律：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Explanation:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><p>我们把每个字符换成它所在行的坐标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0     0    0</span><br><span class="line">1   1 1  1 1</span><br><span class="line">2 2   2 2</span><br><span class="line">3     3</span><br></pre></td></tr></table></figure></p><p>恢复成原始的样子：<code>01232101232101</code>，规律很明显了。所以我们把每个字母放到对应的行上，最后把每行合并即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; num_rows</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(s, num_rows)</span></span></span><br><span class="line">  <span class="keyword">return</span> s <span class="keyword">if</span> num_rows == <span class="number">1</span> <span class="params">||</span> num_rows &gt;= s.length</span><br><span class="line">  characters = Array.new(num_rows) &#123; <span class="string">''</span> &#125;</span><br><span class="line">  index, step = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  s.chars.each <span class="keyword">do</span> <span class="params">|character|</span></span><br><span class="line">    characters[index] += character</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elsif</span> index == num_rows - <span class="number">1</span></span><br><span class="line">      step = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    index += step</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  characters.join</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-ZigZag-Conversion&quot;&gt;&lt;a href=&quot;#6-ZigZag-Conversion&quot; class=&quot;headerlink&quot; title=&quot;6. ZigZag Conversion&quot;&gt;&lt;/a&gt;6. ZigZag Conversion&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>String to Integer (atoi)</title>
    <link href="http://jack0pan.github.io/2018/03/02/String-to-Integer-atoi/"/>
    <id>http://jack0pan.github.io/2018/03/02/String-to-Integer-atoi/</id>
    <published>2018-03-02T13:56:03.000Z</published>
    <updated>2018-06-14T13:13:07.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><ul><li>Only the space character ‘ ‘ is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li></ul><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大体上分为三个步骤：</p><ul><li>先判断正负号，并去掉空格之类的字符</li><li>将字符串按字节遍历，把每个字节对应的数字算出来，并把总数乘10加上这个数</li><li>最后要判断是否溢出</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; str</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_atoi</span><span class="params">(str)</span></span></span><br><span class="line">  str.strip!</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> str.<span class="literal">nil</span>? <span class="keyword">or</span> str.length == <span class="number">0</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">"-"</span></span><br><span class="line">    cs, s = str[<span class="number">1</span>..-<span class="number">1</span>], -<span class="number">1</span></span><br><span class="line">  <span class="keyword">elsif</span> str[<span class="number">0</span>] == <span class="string">"+"</span></span><br><span class="line">    cs, s = str[<span class="number">1</span>..-<span class="number">1</span>], <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cs, s = str, <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> cs.<span class="literal">nil</span>?</span><br><span class="line">  cs.each_byte <span class="keyword">do</span> <span class="params">|b|</span></span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">48</span> <span class="keyword">and</span> b &lt;= <span class="number">57</span></span><br><span class="line">      i = i * <span class="number">10</span> + (b - <span class="number">48</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  i = s * i</span><br><span class="line">  <span class="keyword">if</span> i &lt; -<span class="number">2147483648</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2147483648</span></span><br><span class="line">  <span class="keyword">elsif</span> i &gt; <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;8-String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#8-String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot;8. String to Integer (atoi)&quot;&gt;&lt;/a&gt;8. String t
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Longest Series</title>
    <link href="http://jack0pan.github.io/2018/02/24/Longest-Series/"/>
    <id>http://jack0pan.github.io/2018/02/24/Longest-Series/</id>
    <published>2018-02-24T14:01:19.000Z</published>
    <updated>2018-05-27T01:38:33.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Longest-Series"><a href="#Longest-Series" class="headerlink" title="Longest Series"></a>Longest Series</h1><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Examples:</p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>计算没有重复字母的最长子串。把遍历过的字母都存入hash中，value就是它们的索引值。</p><p>在后面的遍历中如果遇到hash中存在的字符，说明子串已经找出来了，计算长度，并判断是否比存的最大值大。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span><span class="params">(s)</span></span></span><br><span class="line">  max = <span class="number">0</span></span><br><span class="line">  start = <span class="number">0</span></span><br><span class="line">  hash = Hash.new(-<span class="number">1</span>)</span><br><span class="line">  s.chars.each_with_index <span class="keyword">do</span> <span class="params">|char, i|</span></span><br><span class="line">    start = start &gt; hash[char] + <span class="number">1</span> ? start : hash[char] + <span class="number">1</span></span><br><span class="line">    hash[char] = i</span><br><span class="line">    max = max &gt; i - start + <span class="number">1</span> ? max : i - start + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  max</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>以每个元素为中心点，往左右两侧找回文串。</p><p>要考虑奇数回文串和偶数回文串，所以中心点分1个和2个两种情况。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_palindrome</span><span class="params">(s, left, right)</span></span></span><br><span class="line">  n = s.length</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= n-<span class="number">1</span> &amp;&amp; s[left] == s[right])</span><br><span class="line">    left -= <span class="number">1</span></span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  s[(left + <span class="number">1</span>)..(right - <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_palindrome</span><span class="params">(s)</span></span></span><br><span class="line">  i, n = <span class="number">0</span>, s.length</span><br><span class="line">  <span class="keyword">return</span> s <span class="keyword">if</span> n &lt;= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  longest = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; n - <span class="number">1</span></span><br><span class="line">    str = find_palindrome(s, i, i)</span><br><span class="line">    longest = str <span class="keyword">if</span> str.length &gt; longest.length</span><br><span class="line">    str = find_palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">    longest = str <span class="keyword">if</span> str.length &gt; longest.length</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  longest</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All given inputs are in lowercase letters a-z.</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>从数组中找出长度最短的字符串，假设最短字符串就是最长前缀，把数组遍历一遍，查看是否满足。</p><p>不满足就把最短字符串去掉最后一个字符，继续遍历，直到找到满足情况的子串。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String[]&#125; strs</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_common_prefix</span><span class="params">(strs)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> strs.length == <span class="number">0</span></span><br><span class="line">  min_size = <span class="number">10000</span></span><br><span class="line">  min_index = -<span class="number">1</span></span><br><span class="line">  strs.each_with_index <span class="keyword">do</span> <span class="params">|str, index|</span></span><br><span class="line">    <span class="keyword">if</span> str.length &lt; min_size</span><br><span class="line">      min_size = str.length</span><br><span class="line">      min_index = index</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  i = min_size - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &gt;= <span class="number">0</span></span><br><span class="line">    prefix = strs[min_index][<span class="number">0</span>..i]</span><br><span class="line">    found = <span class="literal">true</span></span><br><span class="line">    strs.each_with_index <span class="keyword">do</span> <span class="params">|str, index|</span></span><br><span class="line">      <span class="keyword">next</span> <span class="keyword">if</span> index == min_index</span><br><span class="line">      <span class="keyword">if</span> prefix != str[<span class="number">0</span>..i]</span><br><span class="line">        found = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> prefix <span class="keyword">if</span> found</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(m * n)</code>，m是最短子串的长度，n是数组长度。</li><li>空间复杂度：<code>O(m)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Longest-Series&quot;&gt;&lt;a href=&quot;#Longest-Series&quot; class=&quot;headerlink&quot; title=&quot;Longest Series&quot;&gt;&lt;/a&gt;Longest Series&lt;/h1&gt;&lt;h2 id=&quot;3-Longest-Substri
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Add Two Numbers</title>
    <link href="http://jack0pan.github.io/2018/02/23/Add-Two-Numbers/"/>
    <id>http://jack0pan.github.io/2018/02/23/Add-Two-Numbers/</id>
    <published>2018-02-23T14:01:49.000Z</published>
    <updated>2018-05-27T01:34:43.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这个比较简单，同时遍历两个链表，还有一个进位，把两个链表和进位同时相加，将结果对10取余，并更新进位。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two_numbers</span><span class="params">(l1, l2)</span></span></span><br><span class="line">  l3 = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  c1 = l1</span><br><span class="line">  c2 = l2</span><br><span class="line">  c3 = l3</span><br><span class="line">  carry = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> c1 <span class="keyword">or</span> c2</span><br><span class="line">    x = c1.<span class="literal">nil</span>? ? <span class="number">0</span> : c1.val</span><br><span class="line">    y = c2.<span class="literal">nil</span>? ? <span class="number">0</span> : c2.val</span><br><span class="line">    sum = x + y + carry</span><br><span class="line">    carry = sum / <span class="number">10</span></span><br><span class="line">    c3.<span class="keyword">next</span> = ListNode.new(sum % <span class="number">10</span>)</span><br><span class="line">    c1 = c1.<span class="literal">nil</span>? ? <span class="literal">nil</span> : c1.<span class="keyword">next</span></span><br><span class="line">    c2 = c2.<span class="literal">nil</span>? ? <span class="literal">nil</span> : c2.<span class="keyword">next</span></span><br><span class="line">    c3 = c3.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)</span><br><span class="line">    c3.<span class="keyword">next</span> = ListNode.new(carry)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  l3.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Add-Two-Numbers&quot;&gt;&lt;a href=&quot;#Add-Two-Numbers&quot; class=&quot;headerlink&quot; title=&quot;Add Two Numbers&quot;&gt;&lt;/a&gt;Add Two Numbers&lt;/h1&gt;&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Integer</title>
    <link href="http://jack0pan.github.io/2018/02/23/Reverse-Integer/"/>
    <id>http://jack0pan.github.io/2018/02/23/Reverse-Integer/</id>
    <published>2018-02-23T13:56:03.000Z</published>
    <updated>2018-06-12T14:20:12.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这个好办，就是求所给数除以10的商和余数，将先前的余数乘以10加上余数；得到的商作为下一轮的被除数。<br>一直循环，直到被除数为0。</p><blockquote><p>需要判断溢出的情况</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> x == <span class="number">0</span></span><br><span class="line">  s = x / x.abs</span><br><span class="line">  x = x.abs</span><br><span class="line">  result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> x &gt; <span class="number">0</span></span><br><span class="line">    x, mod = x.divmod(<span class="number">10</span>)</span><br><span class="line">    result = result * <span class="number">10</span> + mod</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  result *= s</span><br><span class="line">  (result &gt; <span class="number">2147483647</span> <span class="keyword">or</span> result &lt; -<span class="number">2147483648</span>) ? <span class="number">0</span> : result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(log10n)</code>，n为输入的整数。</li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;7-Reverse-Integer&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;7. Reverse Integer&quot;&gt;&lt;/a&gt;7. Reverse Integer&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2 3 4 Sum</title>
    <link href="http://jack0pan.github.io/2018/02/22/2-3-4-Sum/"/>
    <id>http://jack0pan.github.io/2018/02/22/2-3-4-Sum/</id>
    <published>2018-02-22T13:46:59.000Z</published>
    <updated>2018-05-27T01:33:39.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-3-4-Sum"><a href="#2-3-4-Sum" class="headerlink" title="2 3 4 Sum"></a>2 3 4 Sum</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>主要思路是用哈希存储元素和索引，key是元素，value是索引。</p><p>遍历数组，用<code>target</code>减去当前元素，得到的差去哈希里找，有对应的值就和当前索引一起返回即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; target</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(nums, target)</span></span></span><br><span class="line">  h = Hash.new</span><br><span class="line">  nums.each_with_index <span class="keyword">do</span> <span class="params">|num, index|</span></span><br><span class="line">    left = target - num</span><br><span class="line">    <span class="keyword">if</span> h[left] </span><br><span class="line">      <span class="keyword">return</span> [h[left], index]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    h[num] = index</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>先把数组排序，这样在遍历数组的时候，如果遇到大于0的数直接结束即可，排序算法最快的是<code>O(nlogn)</code>。</p><p>遍历到当前元素后，取两个指针，分别代表它后面的首尾元素：</p><ul><li>如果和为0，第一个指针后移，第二个前移，直接跳过重复元素</li><li>如果和小于0，第一个指针后移</li><li>如果和大于0，第二个指针前移</li></ul><p>这样直到两个指针相遇。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_sum</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  set = Array.new</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length - <span class="number">2</span></span><br><span class="line">    <span class="keyword">break</span> <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    j = i + <span class="number">1</span></span><br><span class="line">    k = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; k</span><br><span class="line">      <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span></span><br><span class="line">        triplet = [nums[i], nums[j], nums[k]]</span><br><span class="line">        set.push triplet</span><br><span class="line">        j += <span class="number">1</span> <span class="keyword">while</span> nums[j] == nums[j + <span class="number">1</span>]</span><br><span class="line">        k -= <span class="number">1</span> <span class="keyword">while</span> nums[k] == nums[k - <span class="number">1</span>]</span><br><span class="line">        j, k = j + <span class="number">1</span>, k - <span class="number">1</span></span><br><span class="line">      <span class="keyword">elsif</span> nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>这题同样是先排序，然后从头到尾遍历，取当前元素首尾指针：</p><ul><li>如果三个数的和与目标值相同，直接返回目标值；</li><li>比目标值小，首指针后移；</li><li>比目标值大，尾指针前移；</li></ul><p>在整个过程中记录最小距离，最后用目标值减去最小距离即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; target</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_sum_closest</span><span class="params">(nums, target)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  min_diff = <span class="string">"#"</span></span><br><span class="line">  nums.each_with_index <span class="keyword">do</span> <span class="params">|i, index|</span></span><br><span class="line">    j, k = index + <span class="number">1</span>, nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; k</span><br><span class="line">      diff = target - nums[j] - nums[k] - i</span><br><span class="line">      <span class="keyword">return</span> target <span class="keyword">if</span> diff == <span class="number">0</span></span><br><span class="line">      min_diff = diff <span class="keyword">if</span> min_diff == <span class="string">"#"</span> <span class="keyword">or</span> diff.abs &lt; min_diff.abs</span><br><span class="line">      <span class="keyword">if</span> diff &gt; <span class="number">0</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  target - min_diff</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note:</p><p>The solution set must not contain duplicate quadruplets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><p>这题主要思路是把<code>Four Sum</code>问题转化成<code>Two Sum</code>问题：</p><ul><li>先把数组的数两两配对，以它们的和为key，配对为value，存到hash中；</li><li>两两取数，用<code>target</code>减去这两个数的和，用差值去上一步的hash中去找；</li><li>如果找到了，那就和当前两个数组和成结果，这里需要去重。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; target</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">four_sum</span><span class="params">(nums, target)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  table = Hash.new</span><br><span class="line">  result = Array.new</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length - <span class="number">1</span></span><br><span class="line">    j = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; nums.length</span><br><span class="line">      sum = nums[i] + nums[j]</span><br><span class="line">      <span class="keyword">if</span> table.has_key?(sum)</span><br><span class="line">        table[sum].push([i, j])</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        table[sum] = [[i, j]]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length - <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    j = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; nums.length - <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">next</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      other = target - nums[i] - nums[j]</span><br><span class="line">      <span class="keyword">if</span> table.has_key?(other)</span><br><span class="line">        pairs = table[other]</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; pairs.length</span><br><span class="line">          <span class="keyword">if</span> pairs[k][<span class="number">0</span>] &gt; j</span><br><span class="line">            p = [nums[i], nums[j], nums[pairs[k][<span class="number">0</span>]], nums[pairs[k][<span class="number">1</span>]]]</span><br><span class="line">            result.push(p) <span class="keyword">if</span> <span class="keyword">not</span> result.<span class="keyword">include</span>?(p)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^4)</code>，最坏的情况是hash只有一组值，每次需要把这组值都遍历一遍。</li><li>空间复杂度：<code>O(n^2)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-3-4-Sum&quot;&gt;&lt;a href=&quot;#2-3-4-Sum&quot; class=&quot;headerlink&quot; title=&quot;2 3 4 Sum&quot;&gt;&lt;/a&gt;2 3 4 Sum&lt;/h1&gt;&lt;h2 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ教程（六）──远程过程调用</title>
    <link href="http://jack0pan.github.io/2017/10/06/RabbitMQ%E6%95%99%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89%E2%94%80%E2%94%80%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <id>http://jack0pan.github.io/2017/10/06/RabbitMQ教程（六）──远程过程调用/</id>
    <published>2017-10-06T14:13:36.000Z</published>
    <updated>2018-04-09T14:17:07.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h1><p>（使用Ruby客户端）</p><p>在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。</p><p>可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者RPC。</p><p>这篇教程中，我们会使用RabbitMQ来构建一个RPC系统：包含一个客户端和一个RPC服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。</p><a id="more"></a><h2 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h2><p>为了展示RPC服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为<code>call</code>的方法用来发送一个RPC请求，并且在收到回应前保持阻塞。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client = FibonacciClient.new(<span class="string">'rpc_queue'</span>)</span><br><span class="line"></span><br><span class="line">puts <span class="string">' [x] Requesting fib(30)'</span></span><br><span class="line">response = client.call(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">puts <span class="string">" [.] Got <span class="subst">#&#123;response&#125;</span>"</span></span><br></pre></td></tr></table></figure><blockquote><p>关于RPC的注意事项：</p></blockquote><blockquote><p>尽管RPC在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的RPC调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用RPC会导致不可维护的面条代码.</p></blockquote><blockquote><p>考虑到这一点，牢记以下建议：</p></blockquote><blockquote><ul><li>确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。</li><li>给你的系统编写文档。保持各个组件间的依赖明确。</li><li>处理错误案例。明了客户端改如何处理RPC服务器的宕机和长时间无响应情况。</li></ul></blockquote><blockquote><p>当对避免使用RPC有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC类的阻塞。结果被异步地推送到下一个计算场景。</p></blockquote><h2 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h2><p>一般来说通过RabbitMQ来实现RPC是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们试试看：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue = channel.queue(<span class="string">''</span>, <span class="symbol">exclusive:</span> <span class="literal">true</span>)</span><br><span class="line">exchange = channel.default_exchange</span><br><span class="line"></span><br><span class="line">exchange.publish(message, <span class="symbol">routing_key:</span> <span class="string">'rpc_queue'</span>, <span class="symbol">reply_to:</span> queue.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... then code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure><blockquote><p>消息属性</p></blockquote><blockquote><p>AMQP 0.9.1协议给消息预定义了一系列的14个属性。大多数属性很少会用到，除了以下几个：</p></blockquote><blockquote><ul><li><code>:persistent</code>：将消息标记为持久的（值为true）或暂存的（值为false）。第二篇教程里接触过这个属性，记得吧？</li><li><code>:content_type</code>：用来描述编码的mime-type。例如在实际使用中常常使用<code>application/json</code>来描述JOSN编码类型。</li><li><code>:reply_to</code>：通常用来命名回调队列。</li><li><code>:correlation_id</code>：用来将RPC的响应和请求关联起来。</li></ul></blockquote><h2 id="关联标识"><a href="#关联标识" class="headerlink" title="关联标识"></a>关联标识</h2><p>上边介绍的方法中，我们建议给每一个RPC请求新建一个回调队列。这不是一个高效的做法，幸好这儿有一个更好的办法 —— 我们可以为每个客户端只建立一个独立的回调队列。</p><p>这就带来一个新问题，当此队列接收到一个响应的时候它无法辨别出这个响应是属于哪个请求的。<code>:correlation_id</code>就是为了解决这个问题而来的。我们给每个请求设置一个独一无二的值。稍后，当我们从回调队列中接收到一个消息的时候，我们就可以查看这条属性从而将响应和请求匹配起来。如果我们接手到的消息的<code>:correlation_id</code>是未知的，那就直接销毁掉它，因为它不属于我们的任何一条请求。</p><p>你也许会问，为什么我们接收到未知消息的时候不抛出一个错误，而是要将它忽略掉？这是为了解决服务器端有可能发生的竞争情况。尽管可能性不大，但RPC服务器还是有可能在已将应答发送给我们但还未将确认消息发送给请求的情况下死掉。如果这种情况发生，RPC在重启后会重新处理请求。这就是为什么我们必须在客户端优雅的处理重复响应，同时RPC也需要尽可能保持幂等性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="python-six"></p><p>我们的RPC如此工作:</p><ul><li>当客户端启动的时候，它创建一个匿名独享的回调队列。</li><li>在RPC请求中，客户端发送带有两个属性的消息：一个是设置回调队列的<code>:reply_to</code>属性，另一个是设置唯一值的<code>:correlation_id</code>属性。</li><li>将请求发送到一个<code>rpc_queue</code>队列中。</li><li>RPC工作者（又名：服务器）等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给<code>:reply_to</code>字段指定的队列。</li><li>客户端等待回调队列里的数据。当有消息出现的时候，它会检查<code>:correlation_id</code>属性。如果此属性的值与请求匹配，将它返回给应用。</li></ul><h2 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h2><p>斐波那契数列任务：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(value)</span></span></span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">if</span> value.zero? <span class="params">||</span> value == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  fibonacci(value - <span class="number">1</span>) + fibonacci(value - <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>我们声明我们的fibonacci函数，它假设只有合法的正整数当作输入。（别指望这个函数能处理很大的数值，因为它可能是最慢的递归实现方式）。</p><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/ruby/rpc_server.rb" target="_blank" rel="noopener">rpc_server.rb</a>代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env ruby</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'bunny'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciServer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @connection = Bunny.new</span><br><span class="line">    @connection.start</span><br><span class="line">    @channel = @connection.create_channel</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(queue_name)</span></span></span><br><span class="line">    @queue = channel.queue(queue_name)</span><br><span class="line">    @exchange = channel.default_exchange</span><br><span class="line">    subscribe_to_queue</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span></span><br><span class="line">    channel.close</span><br><span class="line">    connection.close</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:channel</span>, <span class="symbol">:exchange</span>, <span class="symbol">:queue</span>, <span class="symbol">:connection</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscribe_to_queue</span></span></span><br><span class="line">    queue.subscribe(<span class="symbol">block:</span> <span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|_delivery_info, properties, payload|</span></span><br><span class="line">      result = fibonacci(payload.to_i)</span><br><span class="line"></span><br><span class="line">      exchange.publish(</span><br><span class="line">        result.to_s,</span><br><span class="line">        <span class="symbol">routing_key:</span> properties.reply_to,</span><br><span class="line">        <span class="symbol">correlation_id:</span> properties.correlation_id</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">if</span> value.zero? <span class="params">||</span> value == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    fibonacci(value - <span class="number">1</span>) + fibonacci(value - <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  server = FibonacciServer.new</span><br><span class="line"></span><br><span class="line">  puts <span class="string">' [x] Awaiting RPC requests'</span></span><br><span class="line">  server.start(<span class="string">'rpc_queue'</span>)</span><br><span class="line"><span class="keyword">rescue</span> Interrupt =&gt; <span class="number">_</span></span><br><span class="line">  server.stop</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>服务器端代码相当简单：</p><ul><li>像往常一样，我们建立连接、通道，并声明队列。</li><li>或许我们希望能在服务器上多开几个线程。为了能将负载平均地分摊到多个服务器，我们需要将通道上的<code>prefetch</code>设置好。</li><li>我们使用<code>Bunny::Queue#subscribe</code>来从队列里接收消息。我们等待请求消息，处理消息，返回响应，然后无线循环以上三步。</li></ul><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/ruby/rpc_client.rb" target="_blank" rel="noopener">rpc_client.rb</a>代码:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env ruby</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'bunny'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'thread'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciClient</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:call_id</span>, <span class="symbol">:response</span>, <span class="symbol">:lock</span>, <span class="symbol">:condition</span>, <span class="symbol">:connection</span>,</span><br><span class="line">                <span class="symbol">:channel</span>, <span class="symbol">:server_queue_name</span>, <span class="symbol">:reply_queue</span>, <span class="symbol">:exchange</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(server_queue_name)</span></span></span><br><span class="line">    @connection = Bunny.new(<span class="symbol">automatically_recover:</span> <span class="literal">false</span>)</span><br><span class="line">    @connection.start</span><br><span class="line"></span><br><span class="line">    @channel = connection.create_channel</span><br><span class="line">    @exchange = channel.default_exchange</span><br><span class="line">    @server_queue_name = server_queue_name</span><br><span class="line"></span><br><span class="line">    setup_reply_queue</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(n)</span></span></span><br><span class="line">    @call_id = generate_uuid</span><br><span class="line"></span><br><span class="line">    exchange.publish(n.to_s,</span><br><span class="line">                     <span class="symbol">routing_key:</span> server_queue_name,</span><br><span class="line">                     <span class="symbol">correlation_id:</span> call_id,</span><br><span class="line">                     <span class="symbol">reply_to:</span> reply_queue.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wait for the signal to continue the execution</span></span><br><span class="line">    lock.synchronize &#123; condition.wait(lock) &#125;</span><br><span class="line"></span><br><span class="line">    response</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span></span><br><span class="line">    channel.close</span><br><span class="line">    connection.close</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup_reply_queue</span></span></span><br><span class="line">    @lock = Mutex.new</span><br><span class="line">    @condition = ConditionVariable.new</span><br><span class="line">    that = <span class="keyword">self</span></span><br><span class="line">    @reply_queue = channel.queue(<span class="string">''</span>, <span class="symbol">exclusive:</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    reply_queue.subscribe <span class="keyword">do</span> <span class="params">|_delivery_info, properties, payload|</span></span><br><span class="line">      <span class="keyword">if</span> properties[<span class="symbol">:correlation_id</span>] == that.call_id</span><br><span class="line">        that.response = payload.to_i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sends the signal to continue the execution of #call</span></span><br><span class="line">        that.lock.synchronize &#123; that.condition.signal &#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate_uuid</span></span></span><br><span class="line">    <span class="comment"># very naive but good enough for code examples</span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;rand&#125;</span><span class="subst">#&#123;rand&#125;</span><span class="subst">#&#123;rand&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">client = FibonacciClient.new(<span class="string">'rpc_queue'</span>)</span><br><span class="line"></span><br><span class="line">puts <span class="string">' [x] Requesting fib(30)'</span></span><br><span class="line">response = client.call(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">puts <span class="string">" [.] Got <span class="subst">#&#123;response&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">client.stop</span><br></pre></td></tr></table></figure></p><p>现在是时候来看一下我们的完整样例代码了：<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/ruby/rpc_client.rb" target="_blank" rel="noopener">rpc_client.rb</a>和<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/ruby/rpc_server.rb" target="_blank" rel="noopener">rpc_server.rb</a>。（尽管它们只有一下基本的异常处理）</p><p>我们的RPC服务已经准备就绪了，现在启动服务器端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby rpc_server.rb</span><br><span class="line"><span class="comment"># =&gt; [x] Awaiting RPC requests</span></span><br></pre></td></tr></table></figure></p><p>运行客户端，请求一个fibonacci数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby rpc_client.rb</span><br><span class="line"><span class="comment"># =&gt; [x] Requesting fib(30)</span></span><br></pre></td></tr></table></figure><p>此处呈现的设计并不是实现RPC服务的唯一方式，但是他有一些重要的优势：</p><ul><li>如果RPC服务器运行的过慢的时候，你可以通过运行另外一个服务器端轻松扩展它。试试在控制台中运行第二个 <code>rpc_server.rb</code>。</li><li>在客户端，RPC请求只发送或接收一条消息。不需要像<code>Bunny::Channel#queue</code>这样的异步调用。所以RPC客户端的单个请求只需要一个网络往返。</li></ul><p>我们的代码依旧非常简单，而且没有试图去解决一些复杂（但是重要）的问题，如：</p><ul><li>当没有服务器运行时，客户端如何作出反映。</li><li>客户端是否需要实现类似RPC超时的东西。</li><li>如果服务器发生故障，并且抛出异常，应该被转发到客户端吗？</li><li>在处理前，防止混入无效的信息（例如检查边界）。</li></ul><blockquote><p>如果你想做一些实验，你会发现<a href="https://www.rabbitmq.com/management.html" target="_blank" rel="noopener">管理页面</a>在观测队列方面是很有用处的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;远程过程调用&quot;&gt;&lt;a href=&quot;#远程过程调用&quot; class=&quot;headerlink&quot; title=&quot;远程过程调用&quot;&gt;&lt;/a&gt;远程过程调用&lt;/h1&gt;&lt;p&gt;（使用Ruby客户端）&lt;/p&gt;
&lt;p&gt;在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。&lt;/p&gt;
&lt;p&gt;可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者RPC。&lt;/p&gt;
&lt;p&gt;这篇教程中，我们会使用RabbitMQ来构建一个RPC系统：包含一个客户端和一个RPC服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://jack0pan.github.io/categories/Ruby/"/>
    
    
      <category term="RabbitMQ" scheme="http://jack0pan.github.io/tags/RabbitMQ/"/>
    
      <category term="Ruby" scheme="http://jack0pan.github.io/tags/Ruby/"/>
    
      <category term="翻译" scheme="http://jack0pan.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
