<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Pan</title>
  
  <subtitle>Jack Pan的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jack0pan.github.io/"/>
  <updated>2018-05-04T14:33:00.420Z</updated>
  <id>http://jack0pan.github.io/</id>
  
  <author>
    <name>Jack Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Construct Binary Tree from Traversal</title>
    <link href="http://jack0pan.github.io/2018/05/04/Construct-Binary-Tree-from-Traversal/"/>
    <id>http://jack0pan.github.io/2018/05/04/Construct-Binary-Tree-from-Traversal/</id>
    <published>2018-05-04T14:31:49.000Z</published>
    <updated>2018-05-04T14:33:00.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Construct-Binary-Tree-from-Traversal"><a href="#Construct-Binary-Tree-from-Traversal" class="headerlink" title="Construct Binary Tree from Traversal"></a>Construct Binary Tree from Traversal</h1><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure></p><p>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>通过前序遍历数组我们可以知道第一个元素为根节点，然后去中序遍历中找到该元素，它左边的为左子树，右边的为右子树。这样递归遍历两个数组即可得到二叉树。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; preorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; inorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(preorder, inorder)</span></span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  inorder.each_with_index <span class="keyword">do</span> <span class="params">|v, i|</span></span><br><span class="line">    hash[v] = i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  _build_tree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _build_tree<span class="params">(preorder, pre_left, pre_right, inorder, in_left, in_right, hash)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> pre_left &gt; pre_right <span class="keyword">or</span> in_left &gt; in_right</span><br><span class="line">  root = TreeNode.new(preorder[pre_left])</span><br><span class="line">  delta = hash[root.val] - in_left</span><br><span class="line">  root.left = _build_tree(preorder, pre_left + <span class="number">1</span>, pre_left + delta, inorder, in_left, hash[root.val] - <span class="number">1</span>, hash)</span><br><span class="line">  root.right = _build_tree(preorder, pre_left + delta + <span class="number">1</span>, pre_right, inorder, hash[root.val] + <span class="number">1</span>, in_right, hash)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure></p><p>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>通过后序遍历数组我们可以知道最后一个元素为根节点，然后去中序遍历中找到该元素，它左边的为左子树，右边的为右子树。这样递归遍历两个数组即可得到二叉树。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; inorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; postorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(inorder, postorder)</span></span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  inorder.each_with_index <span class="keyword">do</span> <span class="params">|v, i|</span></span><br><span class="line">    hash[v] = i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  _build_tree(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _build_tree<span class="params">(postorder, post_left, post_right, inorder, in_left, in_right, hash)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> post_left &gt; post_right <span class="keyword">or</span> in_left &gt; in_right</span><br><span class="line">  root = TreeNode.new(postorder[post_right])</span><br><span class="line">  delta = hash[root.val] - in_left</span><br><span class="line">  root.left = _build_tree(postorder, post_left, post_left + delta - <span class="number">1</span>, inorder, in_left, hash[root.val] - <span class="number">1</span>, hash)</span><br><span class="line">  root.right = _build_tree(postorder, post_left + delta, post_right - <span class="number">1</span>, inorder, hash[root.val] + <span class="number">1</span>, in_right, hash)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Construct-Binary-Tree-from-Traversal&quot;&gt;&lt;a href=&quot;#Construct-Binary-Tree-from-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Construct Binary Tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="http://jack0pan.github.io/2018/05/04/Binary-Tree-Level-Order-Traversal/"/>
    <id>http://jack0pan.github.io/2018/05/04/Binary-Tree-Level-Order-Traversal/</id>
    <published>2018-05-04T13:57:18.000Z</published>
    <updated>2018-05-04T14:29:10.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h1><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>二叉树的广度优先遍历。遍历当前层的同时，把子节点放入队列中，这样一层一层遍历，直到队列为空。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result &lt;&lt; level</span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. Binary Tree Level Order Traversal II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its bottom-up level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这题和<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">前面题</a>一样，只需把最后结构逆序即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_bottom</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result &lt;&lt; level</span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result.reverse</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its zigzag level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>这题在<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>基础上，加个标记，偶数行做一下反转即可。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzag_level_order</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  reverse = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> reverse</span><br><span class="line">      result &lt;&lt; level.reverse</span><br><span class="line">      reverse = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result &lt;&lt; level</span><br><span class="line">      reverse = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Level-Order-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Level-Order-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Level Order Tr
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Unique Binary Search Trees</title>
    <link href="http://jack0pan.github.io/2018/05/03/Unique-Binary-Search-Trees/"/>
    <id>http://jack0pan.github.io/2018/05/03/Unique-Binary-Search-Trees/</id>
    <published>2018-05-03T13:44:32.000Z</published>
    <updated>2018-05-03T14:35:34.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h1><h2 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>解决思路就是以任意一个数为根，比它小的数为左子树，大的为右子树，二叉搜索树的数量就是左子树数量乘以右子树的数量，总数就是以每个数为根节点的二叉搜索树的总和。</p><p>总结成公式为：<br><img src="http://junzhepanblog.qiniudn.com/unique-binary-search-trees/catalan.png" alt="卡特兰数"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_trees</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">  result = Array.new(n + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  result[<span class="number">0</span>], result[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>..n).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    i.times.each <span class="keyword">do</span> <span class="params">|j|</span></span><br><span class="line">      result[i] += result[j] * result[i - j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result[n]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="95-Unique-Binary-Search-Trees"><a href="#95-Unique-Binary-Search-Trees" class="headerlink" title="95. Unique Binary Search Trees"></a>95. Unique Binary Search Trees</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>思路跟<a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Unique Binary Search Trees</a>的类似。</p><ul><li>每选一个节点为根，就要递归求解左右子树的所有情况。</li><li>遍历左右子树的所有情况，把当前节点和左右子树拼接起来。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_trees</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">  _generate_trees(<span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _generate_trees<span class="params">(left, right)</span></span></span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">if</span> left &gt; right</span><br><span class="line">    result &lt;&lt; <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    (left..right).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      lefts = _generate_trees(left, i - <span class="number">1</span>)</span><br><span class="line">      rights = _generate_trees(i + <span class="number">1</span>, right)</span><br><span class="line">      lefts.length.times.each <span class="keyword">do</span> <span class="params">|j|</span></span><br><span class="line">        rights.length.times.each <span class="keyword">do</span> <span class="params">|k|</span></span><br><span class="line">          root = TreeNode.new(i)</span><br><span class="line">          root.left = lefts[j]</span><br><span class="line">          root.right = rights[k]</span><br><span class="line">          result &lt;&lt; root</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unique-Binary-Search-Trees&quot;&gt;&lt;a href=&quot;#Unique-Binary-Search-Trees&quot; class=&quot;headerlink&quot; title=&quot;Unique Binary Search Trees&quot;&gt;&lt;/a&gt;Unique B
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Deep Traversal</title>
    <link href="http://jack0pan.github.io/2018/04/28/Binary-Tree-Deep-Traversal/"/>
    <id>http://jack0pan.github.io/2018/04/28/Binary-Tree-Deep-Traversal/</id>
    <published>2018-04-28T15:06:25.000Z</published>
    <updated>2018-05-05T02:38:49.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Deep-Traversal"><a href="#Binary-Tree-Deep-Traversal" class="headerlink" title="Binary Tree Deep Traversal"></a>Binary Tree Deep Traversal</h1><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>二叉树中序遍历，题目要求迭代方式实现。</p><p>先来看递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>再看迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">or</span> <span class="keyword">not</span> stack.empty?</span><br><span class="line">    <span class="keyword">while</span> node</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    node = stack.pop</span><br><span class="line">    path &lt;&lt; node.val</span><br><span class="line">    node = node.right</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>二叉树前序遍历</p><p>递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">or</span> <span class="keyword">not</span> stack.empty?</span><br><span class="line">    <span class="keyword">while</span> node</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    node = stack.pop</span><br><span class="line">    node = node.right</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>二叉树后序遍历</p><p>递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> stack.empty? <span class="keyword">or</span> path.empty?</span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left ? node.left : node.right</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      next_node = stack.pop </span><br><span class="line">      node = stack.last </span><br><span class="line">      <span class="keyword">while</span> node &amp;&amp; node.right == next_node</span><br><span class="line">        path &lt;&lt; next_node.val </span><br><span class="line">        next_node = stack.pop </span><br><span class="line">        node = stack.last </span><br><span class="line">      <span class="keyword">end</span> </span><br><span class="line">      node = node ? node.right : <span class="literal">nil</span></span><br><span class="line">      path &lt;&lt; next_node.val</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Deep-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Deep-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Deep Traversal&quot;&gt;&lt;/a&gt;Binary T
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Validate Binary Search Tree</title>
    <link href="http://jack0pan.github.io/2018/04/28/Validate-Binary-Search-Tree/"/>
    <id>http://jack0pan.github.io/2018/04/28/Validate-Binary-Search-Tree/</id>
    <published>2018-04-28T13:47:19.000Z</published>
    <updated>2018-05-05T02:47:39.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value</span><br><span class="line">             is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>验证一棵二叉树是否为二叉搜索树。</p><p>思路就是递归验证左子树和右子树是否都满足条件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Boolean&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_bst</span><span class="params">(root, l = <span class="literal">nil</span>, r = <span class="literal">nil</span>)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> l &amp;&amp; l &gt; root.val</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> r &amp;&amp; r &lt; root.val</span><br><span class="line"></span><br><span class="line">  is_valid_bst(root.left, l, root.val - <span class="number">1</span>) &amp;&amp; is_valid_bst(root.right, root.val + <span class="number">1</span>, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(logn)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;98-Validate-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#98-Validate-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;98. Validate Binary Search Tree&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Restore IP Addresses</title>
    <link href="http://jack0pan.github.io/2018/04/27/Restore-IP-Addresses/"/>
    <id>http://jack0pan.github.io/2018/04/27/Restore-IP-Addresses/</id>
    <published>2018-04-27T14:01:17.000Z</published>
    <updated>2018-05-05T02:31:44.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这题思路主要是用动态规划，没什么好说的。主要在于对IP的每一项的判断要筛掉以下情况：</p><ul><li>每一项的值不能大于255</li><li>不能以“0”开头（比如：01，00），这种可以通过先转成整数，再转成字符串，和原来比较是否相同。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restore_ip_addresses</span><span class="params">(s)</span></span></span><br><span class="line">  ips = []</span><br><span class="line">  ip = []</span><br><span class="line">  _restore(ips, ip, s, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> ips</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _restore<span class="params">(ips, ip, s, level)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> s.<span class="literal">nil</span>? <span class="keyword">or</span> s.empty?</span><br><span class="line">  <span class="keyword">if</span> level == <span class="number">4</span></span><br><span class="line">    p = s.to_i</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> p &gt; <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> p.to_s != s</span><br><span class="line">    ip.push(s)</span><br><span class="line">    ips.push(ip.join(<span class="string">'.'</span>))</span><br><span class="line">    ip.pop</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">3</span>.times.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> s.length &lt; (i + <span class="number">1</span>)</span><br><span class="line">      p = s[<span class="number">0</span>..i].to_i</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> p &gt; <span class="number">255</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> p.to_s != s[<span class="number">0</span>..i]</span><br><span class="line">      ip.push(s[<span class="number">0</span>..i])</span><br><span class="line">      _restore(ips, ip, s[(i+<span class="number">1</span>)..-<span class="number">1</span>], level + <span class="number">1</span>)</span><br><span class="line">      ip.pop</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>这题的时间和空间复杂度是固定的，都是<code>O(3^4)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;93-Restore-IP-Addresses&quot;&gt;&lt;a href=&quot;#93-Restore-IP-Addresses&quot; class=&quot;headerlink&quot; title=&quot;93. Restore IP Addresses&quot;&gt;&lt;/a&gt;93. Restore IP A
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="http://jack0pan.github.io/2018/04/26/Reverse-Linked-List/"/>
    <id>http://jack0pan.github.io/2018/04/26/Reverse-Linked-List/</id>
    <published>2018-04-26T13:44:32.000Z</published>
    <updated>2018-05-05T03:29:43.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h1><h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Reverse a singly linked list.</p><p>Hint:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>题目要求两种实现思路：迭代方式和递归方式。</p><h4 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h4><p>先创建一个临时节点，从头往后遍历链表，来一个节点就插入临时节点和第一个节点之间，这样遍历完后，链表就逆序了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iteratively implement</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span></span></span><br><span class="line">  dummy_head = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  p = head</span><br><span class="line">  <span class="keyword">while</span> p</span><br><span class="line">    n = p.<span class="keyword">next</span></span><br><span class="line">    p.<span class="keyword">next</span> = dummy_head.<span class="keyword">next</span></span><br><span class="line">    dummy_head.<span class="keyword">next</span> = p</span><br><span class="line">    p = n</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  dummy_head.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><p>递归结束条件是遍历到最后一个节点，直接返回。其他情况就是让下一个节点指向当前节点。中间要一直返回最后一个节点，递归完后，最后一个节点就变成第一个节点了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># recursively implement</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span></span></span><br><span class="line">  <span class="keyword">if</span> head.<span class="literal">nil</span>? <span class="keyword">or</span> head.<span class="keyword">next</span>.<span class="literal">nil</span>?</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    n = head.<span class="keyword">next</span></span><br><span class="line">    head.<span class="keyword">next</span> = <span class="literal">nil</span></span><br><span class="line">    rest = reverse_list(n)</span><br><span class="line">    n.<span class="keyword">next</span> = head</span><br><span class="line">    <span class="keyword">return</span> rest</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Reverse a linked list from position m to n. Do it in one-pass.</p><p>Note: 1 ≤ m ≤ n ≤ length of list.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这题解法就是，先找到m节点的位置，然后把m和n之间的节点插入m节点和它之前节点就行。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; m</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_between</span><span class="params">(head, m, n)</span></span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> head.<span class="literal">nil</span>?</span><br><span class="line">  dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  dummy.<span class="keyword">next</span> = head</span><br><span class="line">  m_prev, i = dummy, <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> m_prev.<span class="keyword">next</span></span><br><span class="line">    m_prev = m_prev.<span class="keyword">next</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> i &lt; m</span><br><span class="line">  m_node = m_prev.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> m_node.<span class="literal">nil</span>?</span><br><span class="line">  c_node = m_node.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> c_node</span><br><span class="line">    t = c_node.<span class="keyword">next</span></span><br><span class="line">    c_node.<span class="keyword">next</span> = m_prev.<span class="keyword">next</span></span><br><span class="line">    m_prev.<span class="keyword">next</span> = c_node</span><br><span class="line">    c_node = t</span><br><span class="line">    m_node.<span class="keyword">next</span> = c_node</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Linked List&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Decode Ways</title>
    <link href="http://jack0pan.github.io/2018/04/25/Decode-Ways/"/>
    <id>http://jack0pan.github.io/2018/04/25/Decode-Ways/</id>
    <published>2018-04-25T14:06:22.000Z</published>
    <updated>2018-05-06T03:35:25.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h1><h2 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure></p><p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们用<code>dp[i]</code>表示以第i个数字结尾的子串编码数量，计算公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] += dp[i-1] 如果s[i-1] &gt; 0</span><br><span class="line">dp[i] += dp[i-2] 如果10 &lt;= s[i-2]s[i-1] &lt;= 26</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_decodings</span><span class="params">(s)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> s.<span class="literal">nil</span>? <span class="keyword">or</span> s.empty? <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span></span><br><span class="line">  dp = Array.new(s.length + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>..s.length).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    dp[i] += dp[i - <span class="number">1</span>] <span class="keyword">if</span> s[i - <span class="number">1</span>].to_i &gt; <span class="number">0</span></span><br><span class="line">    dp[i] += dp[i - <span class="number">2</span>] <span class="keyword">if</span> s[i - <span class="number">2</span>.. i - <span class="number">1</span>].to_i &gt;= <span class="number">10</span> <span class="keyword">and</span> s[i - <span class="number">2</span>.. i - <span class="number">1</span>].to_i &lt;= <span class="number">26</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  dp[s.length]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Decode-Ways&quot;&gt;&lt;a href=&quot;#Decode-Ways&quot; class=&quot;headerlink&quot; title=&quot;Decode Ways&quot;&gt;&lt;/a&gt;Decode Ways&lt;/h1&gt;&lt;h2 id=&quot;91-Decode-Ways&quot;&gt;&lt;a href=&quot;#91-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Subsets</title>
    <link href="http://jack0pan.github.io/2018/04/24/Subsets/"/>
    <id>http://jack0pan.github.io/2018/04/24/Subsets/</id>
    <published>2018-04-24T13:56:24.000Z</published>
    <updated>2018-05-06T03:37:25.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h1><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>利用深度优先算法，把所有组合情况都遍历一遍。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  path, result = [], []</span><br><span class="line">  _subsets(nums, <span class="number">0</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _subsets<span class="params">(nums, index, path, result)</span></span></span><br><span class="line">  result.push(path.dup)</span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length</span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    _subsets(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">    path.pop</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul><h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这道题和<a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Subsets</a>的区别在于去掉重复元素，最直接的办法就是在添加一种新组合前，判断一下是否已经含有这种组合。但是，这种做法增加了时间复杂度，LeetCode上的运行时间是<code>100ms</code>。</p><p>还有一种更有效的办法，在把元素添加到组合中，直接跳过重复元素。这种做法可以把时间缩短到<code>40ms</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets_with_dup</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  path, result = [], []</span><br><span class="line">  _subsets(nums, <span class="number">0</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _subsets<span class="params">(nums, index, path, result)</span></span></span><br><span class="line">  result.push(path.dup)</span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length</span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    _subsets(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">    path.pop</span><br><span class="line">    i += <span class="number">1</span> <span class="keyword">while</span> i &lt; nums.length - <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Subsets&quot;&gt;&lt;a href=&quot;#Subsets&quot; class=&quot;headerlink&quot; title=&quot;Subsets&quot;&gt;&lt;/a&gt;Subsets&lt;/h1&gt;&lt;h2 id=&quot;78-Subsets&quot;&gt;&lt;a href=&quot;#78-Subsets&quot; class=&quot;head
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Gray Code</title>
    <link href="http://jack0pan.github.io/2018/04/23/Gray-Code/"/>
    <id>http://jack0pan.github.io/2018/04/23/Gray-Code/</id>
    <published>2018-04-23T14:01:20.000Z</published>
    <updated>2018-05-12T14:57:40.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure></p><p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p><p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p><p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>题目让生成格雷码，要生成n的格雷码，总共有2的n次方个，第i个生成方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &gt;&gt; 1) ^ i</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray_code</span><span class="params">(n)</span></span></span><br><span class="line">  i, total, result = <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n, []</span><br><span class="line">  total.times.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    result.push((i <span class="meta">&gt;&gt; </span><span class="number">1</span>) ^ i)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(2^n)</code></li><li>空间复杂度：<code>O(2^n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;89-Gray-Code&quot;&gt;&lt;a href=&quot;#89-Gray-Code&quot; class=&quot;headerlink&quot; title=&quot;89. Gray Code&quot;&gt;&lt;/a&gt;89. Gray Code&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Partition List</title>
    <link href="http://jack0pan.github.io/2018/04/20/Partition-List/"/>
    <id>http://jack0pan.github.io/2018/04/20/Partition-List/</id>
    <published>2018-04-20T14:05:10.000Z</published>
    <updated>2018-05-14T15:37:25.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>方法就是从头到尾遍历链表，把小于给定值的节点从当前链表摘除，添加到新链表中。然后把链表添加到新链表尾部即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(head, x)</span></span></span><br><span class="line">  dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  new_dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  dummy.<span class="keyword">next</span> = head</span><br><span class="line">  cur, new_cur = dummy, new_dummy</span><br><span class="line">  <span class="keyword">while</span> cur.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">if</span> cur.<span class="keyword">next</span>.val &lt; x</span><br><span class="line">      new_cur.<span class="keyword">next</span> = cur.<span class="keyword">next</span></span><br><span class="line">      new_cur = new_cur.<span class="keyword">next</span></span><br><span class="line">      cur.<span class="keyword">next</span> = cur.<span class="keyword">next</span>.<span class="keyword">next</span></span><br><span class="line">      new_cur.<span class="keyword">next</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cur = cur.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  new_cur.<span class="keyword">next</span> = dummy.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">return</span> new_dummy.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;86-Partition-List&quot;&gt;&lt;a href=&quot;#86-Partition-List&quot; class=&quot;headerlink&quot; title=&quot;86. Partition List&quot;&gt;&lt;/a&gt;86. Partition List&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Combinations</title>
    <link href="http://jack0pan.github.io/2018/04/08/Combinations/"/>
    <id>http://jack0pan.github.io/2018/04/08/Combinations/</id>
    <published>2018-04-08T14:11:33.000Z</published>
    <updated>2018-05-16T15:20:50.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这题没啥好解释的，用深度优先搜索来解就行了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; k</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(n, k)</span></span></span><br><span class="line">  path, result = [], []</span><br><span class="line">  _combine(n, k, <span class="number">1</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _combine<span class="params">(n, k, start, path, result)</span></span></span><br><span class="line">  <span class="keyword">if</span> path.size == k</span><br><span class="line">    new_path = path.dup</span><br><span class="line">    result.push(new_path)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = start</span><br><span class="line">    <span class="keyword">while</span> i &lt;= n</span><br><span class="line">      path.push(i);</span><br><span class="line">      _combine(n, k, i + <span class="number">1</span>, path, result)</span><br><span class="line">      path.pop</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;77-Combinations&quot;&gt;&lt;a href=&quot;#77-Combinations&quot; class=&quot;headerlink&quot; title=&quot;77. Combinations&quot;&gt;&lt;/a&gt;77. Combinations&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Container With Most Water</title>
    <link href="http://jack0pan.github.io/2018/03/04/Container-With-Moster-Water/"/>
    <id>http://jack0pan.github.io/2018/03/04/Container-With-Moster-Water/</id>
    <published>2018-03-04T13:57:49.000Z</published>
    <updated>2018-08-25T15:13:13.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="question_11"></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>用左右两个指针分别指向首和尾，用较矮的高度乘以宽度，得到容量，判断是否比之前的大。</p><p>指针移动有两种情况：</p><ul><li>左指针对应的高度较矮，就把左指针右移；</li><li>右指针对应的高度较矮，就把右指针左移。</li></ul><p>就这样循环，直到两个指针相遇。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; height</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_area</span><span class="params">(height)</span></span></span><br><span class="line">  max, left, right = <span class="number">0</span>, <span class="number">0</span>, height.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> left &lt; right</span><br><span class="line">    max = [max, [height[left], height[right]].min * (right - left)].max</span><br><span class="line">    <span class="keyword">if</span> height[left] &lt; height[right]</span><br><span class="line">      left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;11-Container-With-Most-Water&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water&quot; class=&quot;headerlink&quot; title=&quot;11. Container With Most Water&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Number</title>
    <link href="http://jack0pan.github.io/2018/03/03/Palindrome-Number/"/>
    <id>http://jack0pan.github.io/2018/03/03/Palindrome-Number/</id>
    <published>2018-03-03T14:01:03.000Z</published>
    <updated>2018-08-19T12:25:49.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>Coud you solve it without converting the integer to a string?</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>思路是把给的数分成两半，判断两半是否相等。会有两种情况：</p><ul><li>数字位数是偶数，判断两部分是否相等</li><li>数字位数是奇数，将数值大的一半除以10后比较</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Boolean&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>)</span><br><span class="line">  r = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> x &gt; r</span><br><span class="line">    x, mod = x.divmod(<span class="number">10</span>)</span><br><span class="line">    r = r * <span class="number">10</span> + mod</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  x == r <span class="keyword">or</span> x == r / <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)，n是数字的位数</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9-Palindrome-Number&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number&quot;&gt;&lt;/a&gt;9. Palindrome Number&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>ZigZag Conversion</title>
    <link href="http://jack0pan.github.io/2018/03/02/ZigZag-Conversion/"/>
    <id>http://jack0pan.github.io/2018/03/02/ZigZag-Conversion/</id>
    <published>2018-03-02T14:02:47.000Z</published>
    <updated>2018-05-30T14:23:53.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我们先看一个具体的例子来找规律：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Explanation:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><p>我们把每个字符换成它所在行的坐标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0     0    0</span><br><span class="line">1   1 1  1 1</span><br><span class="line">2 2   2 2</span><br><span class="line">3     3</span><br></pre></td></tr></table></figure></p><p>恢复成原始的样子：<code>01232101232101</code>，规律很明显了。所以我们把每个字母放到对应的行上，最后把每行合并即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; num_rows</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(s, num_rows)</span></span></span><br><span class="line">  <span class="keyword">return</span> s <span class="keyword">if</span> num_rows == <span class="number">1</span> <span class="params">||</span> num_rows &gt;= s.length</span><br><span class="line">  characters = Array.new(num_rows) &#123; <span class="string">''</span> &#125;</span><br><span class="line">  index, step = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  s.chars.each <span class="keyword">do</span> <span class="params">|character|</span></span><br><span class="line">    characters[index] += character</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elsif</span> index == num_rows - <span class="number">1</span></span><br><span class="line">      step = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    index += step</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  characters.join</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-ZigZag-Conversion&quot;&gt;&lt;a href=&quot;#6-ZigZag-Conversion&quot; class=&quot;headerlink&quot; title=&quot;6. ZigZag Conversion&quot;&gt;&lt;/a&gt;6. ZigZag Conversion&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>String to Integer (atoi)</title>
    <link href="http://jack0pan.github.io/2018/03/02/String-to-Integer-atoi/"/>
    <id>http://jack0pan.github.io/2018/03/02/String-to-Integer-atoi/</id>
    <published>2018-03-02T13:56:03.000Z</published>
    <updated>2018-06-14T13:13:07.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><ul><li>Only the space character ‘ ‘ is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li></ul><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大体上分为三个步骤：</p><ul><li>先判断正负号，并去掉空格之类的字符</li><li>将字符串按字节遍历，把每个字节对应的数字算出来，并把总数乘10加上这个数</li><li>最后要判断是否溢出</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; str</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_atoi</span><span class="params">(str)</span></span></span><br><span class="line">  str.strip!</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> str.<span class="literal">nil</span>? <span class="keyword">or</span> str.length == <span class="number">0</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">"-"</span></span><br><span class="line">    cs, s = str[<span class="number">1</span>..-<span class="number">1</span>], -<span class="number">1</span></span><br><span class="line">  <span class="keyword">elsif</span> str[<span class="number">0</span>] == <span class="string">"+"</span></span><br><span class="line">    cs, s = str[<span class="number">1</span>..-<span class="number">1</span>], <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cs, s = str, <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> cs.<span class="literal">nil</span>?</span><br><span class="line">  cs.each_byte <span class="keyword">do</span> <span class="params">|b|</span></span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">48</span> <span class="keyword">and</span> b &lt;= <span class="number">57</span></span><br><span class="line">      i = i * <span class="number">10</span> + (b - <span class="number">48</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  i = s * i</span><br><span class="line">  <span class="keyword">if</span> i &lt; -<span class="number">2147483648</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2147483648</span></span><br><span class="line">  <span class="keyword">elsif</span> i &gt; <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;8-String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#8-String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot;8. String to Integer (atoi)&quot;&gt;&lt;/a&gt;8. String t
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Longest Series</title>
    <link href="http://jack0pan.github.io/2018/02/24/Longest-Series/"/>
    <id>http://jack0pan.github.io/2018/02/24/Longest-Series/</id>
    <published>2018-02-24T14:01:19.000Z</published>
    <updated>2018-05-27T01:38:33.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Longest-Series"><a href="#Longest-Series" class="headerlink" title="Longest Series"></a>Longest Series</h1><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Examples:</p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>计算没有重复字母的最长子串。把遍历过的字母都存入hash中，value就是它们的索引值。</p><p>在后面的遍历中如果遇到hash中存在的字符，说明子串已经找出来了，计算长度，并判断是否比存的最大值大。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span><span class="params">(s)</span></span></span><br><span class="line">  max = <span class="number">0</span></span><br><span class="line">  start = <span class="number">0</span></span><br><span class="line">  hash = Hash.new(-<span class="number">1</span>)</span><br><span class="line">  s.chars.each_with_index <span class="keyword">do</span> <span class="params">|char, i|</span></span><br><span class="line">    start = start &gt; hash[char] + <span class="number">1</span> ? start : hash[char] + <span class="number">1</span></span><br><span class="line">    hash[char] = i</span><br><span class="line">    max = max &gt; i - start + <span class="number">1</span> ? max : i - start + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  max</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>以每个元素为中心点，往左右两侧找回文串。</p><p>要考虑奇数回文串和偶数回文串，所以中心点分1个和2个两种情况。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_palindrome</span><span class="params">(s, left, right)</span></span></span><br><span class="line">  n = s.length</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= n-<span class="number">1</span> &amp;&amp; s[left] == s[right])</span><br><span class="line">    left -= <span class="number">1</span></span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  s[(left + <span class="number">1</span>)..(right - <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_palindrome</span><span class="params">(s)</span></span></span><br><span class="line">  i, n = <span class="number">0</span>, s.length</span><br><span class="line">  <span class="keyword">return</span> s <span class="keyword">if</span> n &lt;= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  longest = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; n - <span class="number">1</span></span><br><span class="line">    str = find_palindrome(s, i, i)</span><br><span class="line">    longest = str <span class="keyword">if</span> str.length &gt; longest.length</span><br><span class="line">    str = find_palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">    longest = str <span class="keyword">if</span> str.length &gt; longest.length</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  longest</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All given inputs are in lowercase letters a-z.</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>从数组中找出长度最短的字符串，假设最短字符串就是最长前缀，把数组遍历一遍，查看是否满足。</p><p>不满足就把最短字符串去掉最后一个字符，继续遍历，直到找到满足情况的子串。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String[]&#125; strs</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_common_prefix</span><span class="params">(strs)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> strs.length == <span class="number">0</span></span><br><span class="line">  min_size = <span class="number">10000</span></span><br><span class="line">  min_index = -<span class="number">1</span></span><br><span class="line">  strs.each_with_index <span class="keyword">do</span> <span class="params">|str, index|</span></span><br><span class="line">    <span class="keyword">if</span> str.length &lt; min_size</span><br><span class="line">      min_size = str.length</span><br><span class="line">      min_index = index</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  i = min_size - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &gt;= <span class="number">0</span></span><br><span class="line">    prefix = strs[min_index][<span class="number">0</span>..i]</span><br><span class="line">    found = <span class="literal">true</span></span><br><span class="line">    strs.each_with_index <span class="keyword">do</span> <span class="params">|str, index|</span></span><br><span class="line">      <span class="keyword">next</span> <span class="keyword">if</span> index == min_index</span><br><span class="line">      <span class="keyword">if</span> prefix != str[<span class="number">0</span>..i]</span><br><span class="line">        found = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> prefix <span class="keyword">if</span> found</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(m * n)</code>，m是最短子串的长度，n是数组长度。</li><li>空间复杂度：<code>O(m)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Longest-Series&quot;&gt;&lt;a href=&quot;#Longest-Series&quot; class=&quot;headerlink&quot; title=&quot;Longest Series&quot;&gt;&lt;/a&gt;Longest Series&lt;/h1&gt;&lt;h2 id=&quot;3-Longest-Substri
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Add Two Numbers</title>
    <link href="http://jack0pan.github.io/2018/02/23/Add-Two-Numbers/"/>
    <id>http://jack0pan.github.io/2018/02/23/Add-Two-Numbers/</id>
    <published>2018-02-23T14:01:49.000Z</published>
    <updated>2018-05-27T01:34:43.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这个比较简单，同时遍历两个链表，还有一个进位，把两个链表和进位同时相加，将结果对10取余，并更新进位。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two_numbers</span><span class="params">(l1, l2)</span></span></span><br><span class="line">  l3 = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  c1 = l1</span><br><span class="line">  c2 = l2</span><br><span class="line">  c3 = l3</span><br><span class="line">  carry = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> c1 <span class="keyword">or</span> c2</span><br><span class="line">    x = c1.<span class="literal">nil</span>? ? <span class="number">0</span> : c1.val</span><br><span class="line">    y = c2.<span class="literal">nil</span>? ? <span class="number">0</span> : c2.val</span><br><span class="line">    sum = x + y + carry</span><br><span class="line">    carry = sum / <span class="number">10</span></span><br><span class="line">    c3.<span class="keyword">next</span> = ListNode.new(sum % <span class="number">10</span>)</span><br><span class="line">    c1 = c1.<span class="literal">nil</span>? ? <span class="literal">nil</span> : c1.<span class="keyword">next</span></span><br><span class="line">    c2 = c2.<span class="literal">nil</span>? ? <span class="literal">nil</span> : c2.<span class="keyword">next</span></span><br><span class="line">    c3 = c3.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)</span><br><span class="line">    c3.<span class="keyword">next</span> = ListNode.new(carry)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  l3.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Add-Two-Numbers&quot;&gt;&lt;a href=&quot;#Add-Two-Numbers&quot; class=&quot;headerlink&quot; title=&quot;Add Two Numbers&quot;&gt;&lt;/a&gt;Add Two Numbers&lt;/h1&gt;&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Integer</title>
    <link href="http://jack0pan.github.io/2018/02/23/Reverse-Integer/"/>
    <id>http://jack0pan.github.io/2018/02/23/Reverse-Integer/</id>
    <published>2018-02-23T13:56:03.000Z</published>
    <updated>2018-06-12T14:20:12.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这个好办，就是求所给数除以10的商和余数，将先前的余数乘以10加上余数；得到的商作为下一轮的被除数。<br>一直循环，直到被除数为0。</p><blockquote><p>需要判断溢出的情况</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> x == <span class="number">0</span></span><br><span class="line">  s = x / x.abs</span><br><span class="line">  x = x.abs</span><br><span class="line">  result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> x &gt; <span class="number">0</span></span><br><span class="line">    x, mod = x.divmod(<span class="number">10</span>)</span><br><span class="line">    result = result * <span class="number">10</span> + mod</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  result *= s</span><br><span class="line">  (result &gt; <span class="number">2147483647</span> <span class="keyword">or</span> result &lt; -<span class="number">2147483648</span>) ? <span class="number">0</span> : result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(log10n)</code>，n为输入的整数。</li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;7-Reverse-Integer&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;7. Reverse Integer&quot;&gt;&lt;/a&gt;7. Reverse Integer&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2 3 4 Sum</title>
    <link href="http://jack0pan.github.io/2018/02/22/2-3-4-Sum/"/>
    <id>http://jack0pan.github.io/2018/02/22/2-3-4-Sum/</id>
    <published>2018-02-22T13:46:59.000Z</published>
    <updated>2018-05-27T01:33:39.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-3-4-Sum"><a href="#2-3-4-Sum" class="headerlink" title="2 3 4 Sum"></a>2 3 4 Sum</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>主要思路是用哈希存储元素和索引，key是元素，value是索引。</p><p>遍历数组，用<code>target</code>减去当前元素，得到的差去哈希里找，有对应的值就和当前索引一起返回即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; target</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(nums, target)</span></span></span><br><span class="line">  h = Hash.new</span><br><span class="line">  nums.each_with_index <span class="keyword">do</span> <span class="params">|num, index|</span></span><br><span class="line">    left = target - num</span><br><span class="line">    <span class="keyword">if</span> h[left] </span><br><span class="line">      <span class="keyword">return</span> [h[left], index]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    h[num] = index</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>先把数组排序，这样在遍历数组的时候，如果遇到大于0的数直接结束即可，排序算法最快的是<code>O(nlogn)</code>。</p><p>遍历到当前元素后，取两个指针，分别代表它后面的首尾元素：</p><ul><li>如果和为0，第一个指针后移，第二个前移，直接跳过重复元素</li><li>如果和小于0，第一个指针后移</li><li>如果和大于0，第二个指针前移</li></ul><p>这样直到两个指针相遇。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_sum</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  set = Array.new</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length - <span class="number">2</span></span><br><span class="line">    <span class="keyword">break</span> <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    j = i + <span class="number">1</span></span><br><span class="line">    k = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; k</span><br><span class="line">      <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span></span><br><span class="line">        triplet = [nums[i], nums[j], nums[k]]</span><br><span class="line">        set.push triplet</span><br><span class="line">        j += <span class="number">1</span> <span class="keyword">while</span> nums[j] == nums[j + <span class="number">1</span>]</span><br><span class="line">        k -= <span class="number">1</span> <span class="keyword">while</span> nums[k] == nums[k - <span class="number">1</span>]</span><br><span class="line">        j, k = j + <span class="number">1</span>, k - <span class="number">1</span></span><br><span class="line">      <span class="keyword">elsif</span> nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>这题同样是先排序，然后从头到尾遍历，取当前元素首尾指针：</p><ul><li>如果三个数的和与目标值相同，直接返回目标值；</li><li>比目标值小，首指针后移；</li><li>比目标值大，尾指针前移；</li></ul><p>在整个过程中记录最小距离，最后用目标值减去最小距离即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; target</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_sum_closest</span><span class="params">(nums, target)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  min_diff = <span class="string">"#"</span></span><br><span class="line">  nums.each_with_index <span class="keyword">do</span> <span class="params">|i, index|</span></span><br><span class="line">    j, k = index + <span class="number">1</span>, nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; k</span><br><span class="line">      diff = target - nums[j] - nums[k] - i</span><br><span class="line">      <span class="keyword">return</span> target <span class="keyword">if</span> diff == <span class="number">0</span></span><br><span class="line">      min_diff = diff <span class="keyword">if</span> min_diff == <span class="string">"#"</span> <span class="keyword">or</span> diff.abs &lt; min_diff.abs</span><br><span class="line">      <span class="keyword">if</span> diff &gt; <span class="number">0</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  target - min_diff</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note:</p><p>The solution set must not contain duplicate quadruplets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><p>这题主要思路是把<code>Four Sum</code>问题转化成<code>Two Sum</code>问题：</p><ul><li>先把数组的数两两配对，以它们的和为key，配对为value，存到hash中；</li><li>两两取数，用<code>target</code>减去这两个数的和，用差值去上一步的hash中去找；</li><li>如果找到了，那就和当前两个数组和成结果，这里需要去重。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; target</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">four_sum</span><span class="params">(nums, target)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  table = Hash.new</span><br><span class="line">  result = Array.new</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length - <span class="number">1</span></span><br><span class="line">    j = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; nums.length</span><br><span class="line">      sum = nums[i] + nums[j]</span><br><span class="line">      <span class="keyword">if</span> table.has_key?(sum)</span><br><span class="line">        table[sum].push([i, j])</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        table[sum] = [[i, j]]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length - <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    j = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; nums.length - <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">next</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      other = target - nums[i] - nums[j]</span><br><span class="line">      <span class="keyword">if</span> table.has_key?(other)</span><br><span class="line">        pairs = table[other]</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; pairs.length</span><br><span class="line">          <span class="keyword">if</span> pairs[k][<span class="number">0</span>] &gt; j</span><br><span class="line">            p = [nums[i], nums[j], nums[pairs[k][<span class="number">0</span>]], nums[pairs[k][<span class="number">1</span>]]]</span><br><span class="line">            result.push(p) <span class="keyword">if</span> <span class="keyword">not</span> result.<span class="keyword">include</span>?(p)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^4)</code>，最坏的情况是hash只有一组值，每次需要把这组值都遍历一遍。</li><li>空间复杂度：<code>O(n^2)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-3-4-Sum&quot;&gt;&lt;a href=&quot;#2-3-4-Sum&quot; class=&quot;headerlink&quot; title=&quot;2 3 4 Sum&quot;&gt;&lt;/a&gt;2 3 4 Sum&lt;/h1&gt;&lt;h2 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
