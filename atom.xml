<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Pan</title>
  
  <subtitle>Jack Pan的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jack0pan.github.io/"/>
  <updated>2018-08-28T14:50:11.313Z</updated>
  <id>http://jack0pan.github.io/</id>
  
  <author>
    <name>Jack Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>金融业网络安全攻防大赛Writeups</title>
    <link href="http://jack0pan.github.io/2018/08/09/%E9%87%91%E8%9E%8D%E4%B8%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%A4%A7%E8%B5%9BWriteups/"/>
    <id>http://jack0pan.github.io/2018/08/09/金融业网络安全攻防大赛Writeups/</id>
    <published>2018-08-09T14:03:25.000Z</published>
    <updated>2018-08-28T14:50:11.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="金融业网络安全攻防大赛Writeups"><a href="#金融业网络安全攻防大赛Writeups" class="headerlink" title="金融业网络安全攻防大赛Writeups"></a>金融业网络安全攻防大赛Writeups</h1><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Mysterious-Picture"><a href="#Mysterious-Picture" class="headerlink" title="Mysterious Picture"></a>Mysterious Picture</h3><p>在公司最近的一次项目中，关键数据疑似泄漏。经过某种手段已经把嫌疑锁定在嫌疑人A身上了，但是嫌疑人A的U盘中除了一张图片之外，没有发现任何相关的信息。你能帮助公司找到他泄漏数据的确凿证据吗？</p><p>题目给了一张图片，用StegSolve打开，每个通道都过一遍，发现rgb的最低位都有异常。</p><p>打开Analyse -&gt; Data Extract，选中最低位，直接Preview，没有flag。切换Bit Plane Order，切到BGR，发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do u know how the bad man send secret messages now? flag&#123;babylsbstego_cannot_be_easier!%^%^&amp;&#125;.</span><br></pre></td></tr></table></figure></p><h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>MD5($a) = d78b6f30225cdc811adfe8d4e7c9fd34<br>MD5($b) = 8fc42c6ddf9966db3b09e84365034357<br>MD5($c) = 5f295bce38d311f26a96eb811192f391</p><p>flag{$a_$b_$c}</p><p>直接在网上搜索得到：<br>$a = hack<br>$b = the<br>$c = planet<br>所以flag是：<code>flag{hack_the_planet}</code></p><h3 id="Backdoor"><a href="#Backdoor" class="headerlink" title="Backdoor"></a>Backdoor</h3><p>某银行安全团队在分析流量日志的过程中，发现了在 DMZ 区域的服务器被黑客入侵且放置了后门。运维部门提取出了流量中最可疑的部分，据有经验的安全专家分析，这里面应该包含了黑客上传的入侵证据文件，你能找到黑客入侵过程中出现了什么证据信息吗？</p><p>分析http流，把cmdcmdcmd参数base64解密，找到一段有用的：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@ini_set(<span class="string">"display_errors"</span>,<span class="string">"0"</span>);</span><br><span class="line">@set_time_limit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(PHP_VERSION&lt;<span class="string">'5.3.0'</span>)&#123;</span><br><span class="line">  @set_magic_quotes_runtime(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">"X@Y"</span>);</span><br><span class="line">$f=<span class="string">'C:\\phpStudy\\WWW\\uploads\\reverseshell.zip'</span>;</span><br><span class="line">$c=$_POST[<span class="string">"z1"</span>];</span><br><span class="line">$c=str_replace(<span class="string">"\r"</span>,<span class="string">""</span>,$c);</span><br><span class="line">$c=str_replace(<span class="string">"\n"</span>,<span class="string">""</span>,$c);</span><br><span class="line">$buf=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($c);$i+=<span class="number">2</span>)</span><br><span class="line">$buf.=urldecode(<span class="string">'%'</span>.substr($c,$i,<span class="number">2</span>));</span><br><span class="line"><span class="keyword">echo</span>(@fwrite(fopen($f,<span class="string">'w'</span>),$buf)?<span class="string">'1'</span>:<span class="string">'0'</span>);;</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">"X@Y"</span>);</span><br><span class="line"><span class="keyword">die</span>();</span><br></pre></td></tr></table></figure></p><p>代码意思就是z1参数写入文件，z1参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">504B0304140000000800288DC34C58BD2C542C0500002C0700000E000000313532383031383837352E706E676D956D54926718C7B12C4D33ED45CD94B034E9D4C9B6F2A5D4503B1A5A274CB1B2E341A798D35EA82D4D110173B9AD48C8B9B2A395A5A8684C84694D54B0B65646BA91C0A333C2487C8530ECE909151C7E4BE19CDFFD7CB8CF7D5FE77F5FD7F5BF9E2B47306807BB0D763018CC213A2A220E06B35A3FBF6C9798766CD59401186CF9547444787CEE6D8D3C96FE6ECFCA659D3DA95AAAEACD52F6CAA8412F955F03CA66DF43E550386C0BB652A15020EE0D570E2C2D10865DF7FC9241854A484155BEFD4E7D8B2DD1865E52B1EE1A67C488E3A6CFEF7C63B62B42C4ACB3397DA01016BE80826C3D69EC8E74A44B790E0B12E71834460DAAA09A94BDAE45A1F79AFDDA2BFCB26778C1177486EB49F582C84709FFB2013AF4A019744C64DF105E28FB081AF702D4CBA1E9DE3F3B79DB7E09EBA65031C67AF19A8B20F2BCE512728D406AC8C3517E715BB1C47A21C6747D5B3D1485436BB5D1C06903E7A499DA79C1E341AFC01BC5CAEDB0987297FC727AAD667D58EFF8B16755BD20E22DC36DC5E6454157BD5050B31FE5A3F1F0A5B9D3EFAA00A36D779493E74226897FF6F45FED7210A3CBE4817B0BE8FBE4871D6684347385C3E5A3819A0139878BD9F8208F999071F7B593A187E4FF5B98074E76CDDAAA7021525D4E07A18F3B95A363F54EB400B58EC1C422EECD51508422EF4C5F982413197BA7752C425FEC34BB8C490BE671722288711E09860A78A286E5D8F9FEDC2D1F33DD5F411B220D4C71570F6A06CA1BD9EE5E7A07AC40A9D35CEF07ED5E636DBB90663F71657E7155639F7A384FC4F42AC54D069F5295C624BA6E5A1CB8C9971AE3125D7635F1090D08E19F3124C1C7491A48EA1A40F74D6C2FF1DD3F99B4E89D366D42DA3E35C38E078FD4545BA919E379C9FA6AA516ECF8548AB868A1CE28B87424AF98572F49F2E864A6DECFFF1E82C4EB7D84FD7452266549B1B5D979192776DD71F7719A33DCDEFE703781DE782299B3B5BC1D48739C9978699694264AB17270CEF1624D6B92CF1BE83F253864BF0BDF62ACF599469B1F3E7FFE4735B8DCEFA9306403157BA18AFC1439F93105098181E00411699E448FDB9B667A367E02D02DD426B5D879DCA083E63EB7D975CF01F1BF86A69A9BEB876164A9212CE8FDD1D0632D99100496E7F6B636E283479103C21093B70A16798B3F2B8FDDDCFE2660DAC1F92DD74AE20FBA55CEA623735A2A4A3C17B97DDEF046371EBCAE3CA0E30057D21C72D44FFFEAA0BC2F351D61AE3ABE6274A7545452BA654C799271F01160DF7D088E76F1C0A5E8EA6A684EED65161C9E193C0556631427EA1A2BCE5C6E8E6F3F4EE690D79A47668B14A5D211BA08F3FE3961DBF300693D64D344E500379990146DEEDEF959C3F636A4093F0F64C94E61C1563C2E8527D60FA13E18ACDA2F99F78989866F9F63F8145606F931132F9DB853DD909CA2CB559263A05D96B28763BB07C03FF66749329F3D7000FF0E021847C99A354F045D96065FABEF7EB420437BA14322E08C71F3C54087242BE4C96A8B4527E13ECCF6D69276F867CB76DEDD7104D1C9CCA18F5F31572C53696BBA5EE0B94654FF2CD334CAB01F72E61ECB62C49A3D9C8794223A72127FA0D076718FE8A038ACB66415B8ED6CEF4F9A0CA1E96A1A6FAB826974BE65A9ECF7F8F42C1C79D9601B5F7AA63C24E153C62582EEA552E9BED642774F822A2DF9305985FCE7FAD96DD181FE32E28868F521708B93851E1129929B0FF1EBB93D436BFFA05C256011350691E021BEC4FC91A6890A044EB9F86B8C465FB8CD3046F697A215303EBB66BD7AD15CA80C3DF2AAC88243E7952176AF6B886B2408969BFE82B0E8484C44E3FE6F0AFF07504B01021400140000000800288DC34C58BD2C542C0500002C0700000E0000000000000000002000000000000000313532383031383837352E706E67504B050600000000010001003C000000580500000000</span><br></pre></td></tr></table></figure></p><p>得到zip文件，解压后是一张二维码：</p><p>扫描二维码，得到flag：<code>flag{b3c4r3fortheChinaChopperFHGJKUI^U%}</code>。</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="Encrypted-Traffic"><a href="#Encrypted-Traffic" class="headerlink" title="Encrypted Traffic"></a>Encrypted Traffic</h3><p>某银行客户端以安全著称，所有网络流量都开启了密码学防护机制。有一天，你抓到了局域网中的网银登录流量。在这个流量中，密码字段的值为 ac22543d5382cbf48b6ebcf6e40f123d9ca4b91f9998e4c2f2422402。根据分析，你获得了如下的线索：<br>1.上面抓到的登录流量密码字段是 SHA 系列哈希算法的哈希值。<br>2.这个登录密码也是银行卡的 ATM 取款密码。<br>3.登录密码的哈希值是加盐之后计算的结果，根据逆向分析，盐的值是用户名的拼音，而你推测出了流量来自于邻居 “张三丰”</p><p>有了这些线索之后，你能够分析出密码是什么吗？</p><p>flag 提交格式： flag{密码<em>哈希算法</em>盐}<br>举例： flag{123456_SHA999_lisi}</p><p>拿到hash之后，直接上hash-identifier，识别出是：SHA224。<br>密码是六位数字，直接爆破：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">target = <span class="string">'ac22543d5382cbf48b6ebcf6e40f123d9ca4b91f9998e4c2f2422402'</span></span><br><span class="line">salt = <span class="string">'zhangsanfeng'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                        password = str(i) + str(j) + str(k) + str(l) + str(m) + str(n)</span><br><span class="line">                        h = hashlib.sha224(password + salt).hexdigest()</span><br><span class="line">                        <span class="keyword">if</span> h == target:</span><br><span class="line">                            <span class="keyword">print</span> password</span><br><span class="line">                            exit()</span><br></pre></td></tr></table></figure></p><p>得到密码：877295，拼成flag：<code>flag{877295_SHA224_zhangsanfeng}</code>。</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="Ransomware"><a href="#Ransomware" class="headerlink" title="Ransomware"></a>Ransomware</h3><p>公司财务人员的电脑中了勒索软件，财务报表被加密了，必须向攻击者支付比特币才能获得解密密码。作为安全人员，你有办法分析出解密密码吗？</p><p>IDA逆向，F5，得到关键函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401010</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+0h] [ebp-4h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [esp+0h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">18</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + a1) ^= <span class="number">0xCC</span>u;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">18</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="keyword">char</span> *)(j + a1) != byte_404000[j] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逻辑就是得到的密码与<code>0xcc</code>异或，判断结果是否为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FD 93 A8 83 93 A2 FC B8 93 BB 8D A2 A2 AD 93 AF BE B5</span><br></pre></td></tr></table></figure></p><p>把结果和<code>0xcc</code>异或就得到密码了：<code>flag{1_dO_n0t_wAnna_cry}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;金融业网络安全攻防大赛Writeups&quot;&gt;&lt;a href=&quot;#金融业网络安全攻防大赛Writeups&quot; class=&quot;headerlink&quot; title=&quot;金融业网络安全攻防大赛Writeups&quot;&gt;&lt;/a&gt;金融业网络安全攻防大赛Writeups&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="CTF" scheme="http://jack0pan.github.io/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://jack0pan.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Construct Binary Tree from Traversal</title>
    <link href="http://jack0pan.github.io/2018/05/04/Construct-Binary-Tree-from-Traversal/"/>
    <id>http://jack0pan.github.io/2018/05/04/Construct-Binary-Tree-from-Traversal/</id>
    <published>2018-05-04T14:31:49.000Z</published>
    <updated>2018-05-04T14:33:00.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Construct-Binary-Tree-from-Traversal"><a href="#Construct-Binary-Tree-from-Traversal" class="headerlink" title="Construct Binary Tree from Traversal"></a>Construct Binary Tree from Traversal</h1><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure></p><p>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>通过前序遍历数组我们可以知道第一个元素为根节点，然后去中序遍历中找到该元素，它左边的为左子树，右边的为右子树。这样递归遍历两个数组即可得到二叉树。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; preorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; inorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(preorder, inorder)</span></span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  inorder.each_with_index <span class="keyword">do</span> <span class="params">|v, i|</span></span><br><span class="line">    hash[v] = i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  _build_tree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _build_tree<span class="params">(preorder, pre_left, pre_right, inorder, in_left, in_right, hash)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> pre_left &gt; pre_right <span class="keyword">or</span> in_left &gt; in_right</span><br><span class="line">  root = TreeNode.new(preorder[pre_left])</span><br><span class="line">  delta = hash[root.val] - in_left</span><br><span class="line">  root.left = _build_tree(preorder, pre_left + <span class="number">1</span>, pre_left + delta, inorder, in_left, hash[root.val] - <span class="number">1</span>, hash)</span><br><span class="line">  root.right = _build_tree(preorder, pre_left + delta + <span class="number">1</span>, pre_right, inorder, hash[root.val] + <span class="number">1</span>, in_right, hash)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure></p><p>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>通过后序遍历数组我们可以知道最后一个元素为根节点，然后去中序遍历中找到该元素，它左边的为左子树，右边的为右子树。这样递归遍历两个数组即可得到二叉树。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; inorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; postorder</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(inorder, postorder)</span></span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  inorder.each_with_index <span class="keyword">do</span> <span class="params">|v, i|</span></span><br><span class="line">    hash[v] = i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  _build_tree(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _build_tree<span class="params">(postorder, post_left, post_right, inorder, in_left, in_right, hash)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> post_left &gt; post_right <span class="keyword">or</span> in_left &gt; in_right</span><br><span class="line">  root = TreeNode.new(postorder[post_right])</span><br><span class="line">  delta = hash[root.val] - in_left</span><br><span class="line">  root.left = _build_tree(postorder, post_left, post_left + delta - <span class="number">1</span>, inorder, in_left, hash[root.val] - <span class="number">1</span>, hash)</span><br><span class="line">  root.right = _build_tree(postorder, post_left + delta, post_right - <span class="number">1</span>, inorder, hash[root.val] + <span class="number">1</span>, in_right, hash)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Construct-Binary-Tree-from-Traversal&quot;&gt;&lt;a href=&quot;#Construct-Binary-Tree-from-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Construct Binary Tre
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="http://jack0pan.github.io/2018/05/04/Binary-Tree-Level-Order-Traversal/"/>
    <id>http://jack0pan.github.io/2018/05/04/Binary-Tree-Level-Order-Traversal/</id>
    <published>2018-05-04T13:57:18.000Z</published>
    <updated>2018-05-04T14:29:10.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h1><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>二叉树的广度优先遍历。遍历当前层的同时，把子节点放入队列中，这样一层一层遍历，直到队列为空。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result &lt;&lt; level</span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. Binary Tree Level Order Traversal II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its bottom-up level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这题和<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">前面题</a>一样，只需把最后结构逆序即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_bottom</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result &lt;&lt; level</span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result.reverse</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its zigzag level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>这题在<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>基础上，加个标记，偶数行做一下反转即可。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzag_level_order</span><span class="params">(root)</span></span></span><br><span class="line">  result, queue = [], []</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  queue &lt;&lt; root</span><br><span class="line">  reverse = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty?</span><br><span class="line">    level = []</span><br><span class="line">    next_level = []</span><br><span class="line">    queue.each <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">      level &lt;&lt; node.val</span><br><span class="line">      next_level &lt;&lt; node.left <span class="keyword">if</span> node.left</span><br><span class="line">      next_level &lt;&lt; node.right <span class="keyword">if</span> node.right</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> reverse</span><br><span class="line">      result &lt;&lt; level.reverse</span><br><span class="line">      reverse = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result &lt;&lt; level</span><br><span class="line">      reverse = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    queue = next_level</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Level-Order-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Level-Order-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Level Order Tr
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Unique Binary Search Trees</title>
    <link href="http://jack0pan.github.io/2018/05/03/Unique-Binary-Search-Trees/"/>
    <id>http://jack0pan.github.io/2018/05/03/Unique-Binary-Search-Trees/</id>
    <published>2018-05-03T13:44:32.000Z</published>
    <updated>2018-05-03T14:35:34.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h1><h2 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>解决思路就是以任意一个数为根，比它小的数为左子树，大的为右子树，二叉搜索树的数量就是左子树数量乘以右子树的数量，总数就是以每个数为根节点的二叉搜索树的总和。</p><p>总结成公式为：<br><img src="http://junzhepanblog.qiniudn.com/unique-binary-search-trees/catalan.png" alt="卡特兰数"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_trees</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">  result = Array.new(n + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  result[<span class="number">0</span>], result[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>..n).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    i.times.each <span class="keyword">do</span> <span class="params">|j|</span></span><br><span class="line">      result[i] += result[j] * result[i - j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result[n]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="95-Unique-Binary-Search-Trees"><a href="#95-Unique-Binary-Search-Trees" class="headerlink" title="95. Unique Binary Search Trees"></a>95. Unique Binary Search Trees</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>思路跟<a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Unique Binary Search Trees</a>的类似。</p><ul><li>每选一个节点为根，就要递归求解左右子树的所有情况。</li><li>遍历左右子树的所有情况，把当前节点和左右子树拼接起来。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;TreeNode[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_trees</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">  _generate_trees(<span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _generate_trees<span class="params">(left, right)</span></span></span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">if</span> left &gt; right</span><br><span class="line">    result &lt;&lt; <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    (left..right).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      lefts = _generate_trees(left, i - <span class="number">1</span>)</span><br><span class="line">      rights = _generate_trees(i + <span class="number">1</span>, right)</span><br><span class="line">      lefts.length.times.each <span class="keyword">do</span> <span class="params">|j|</span></span><br><span class="line">        rights.length.times.each <span class="keyword">do</span> <span class="params">|k|</span></span><br><span class="line">          root = TreeNode.new(i)</span><br><span class="line">          root.left = lefts[j]</span><br><span class="line">          root.right = rights[k]</span><br><span class="line">          result &lt;&lt; root</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unique-Binary-Search-Trees&quot;&gt;&lt;a href=&quot;#Unique-Binary-Search-Trees&quot; class=&quot;headerlink&quot; title=&quot;Unique Binary Search Trees&quot;&gt;&lt;/a&gt;Unique B
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Deep Traversal</title>
    <link href="http://jack0pan.github.io/2018/04/28/Binary-Tree-Deep-Traversal/"/>
    <id>http://jack0pan.github.io/2018/04/28/Binary-Tree-Deep-Traversal/</id>
    <published>2018-04-28T15:06:25.000Z</published>
    <updated>2018-05-05T02:38:49.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Deep-Traversal"><a href="#Binary-Tree-Deep-Traversal" class="headerlink" title="Binary Tree Deep Traversal"></a>Binary Tree Deep Traversal</h1><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>二叉树中序遍历，题目要求迭代方式实现。</p><p>先来看递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>再看迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">or</span> <span class="keyword">not</span> stack.empty?</span><br><span class="line">    <span class="keyword">while</span> node</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    node = stack.pop</span><br><span class="line">    path &lt;&lt; node.val</span><br><span class="line">    node = node.right</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>二叉树前序遍历</p><p>递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">or</span> <span class="keyword">not</span> stack.empty?</span><br><span class="line">    <span class="keyword">while</span> node</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    node = stack.pop</span><br><span class="line">    node = node.right</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure></p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>二叉树后序遍历</p><p>递归方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  path = []</span><br><span class="line">  traverse = lambda &#123; <span class="params">|node|</span></span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      traverse.call(node.left)</span><br><span class="line">      traverse.call(node.right)</span><br><span class="line">      path &lt;&lt; node.val</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line">  traverse.call(root)</span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>迭代方式：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_traversal</span><span class="params">(root)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line">  node, stack, path = root, [], []</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> stack.empty? <span class="keyword">or</span> path.empty?</span><br><span class="line">    <span class="keyword">if</span> node</span><br><span class="line">      stack.push node</span><br><span class="line">      node = node.left ? node.left : node.right</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      next_node = stack.pop </span><br><span class="line">      node = stack.last </span><br><span class="line">      <span class="keyword">while</span> node &amp;&amp; node.right == next_node</span><br><span class="line">        path &lt;&lt; next_node.val </span><br><span class="line">        next_node = stack.pop </span><br><span class="line">        node = stack.last </span><br><span class="line">      <span class="keyword">end</span> </span><br><span class="line">      node = node ? node.right : <span class="literal">nil</span></span><br><span class="line">      path &lt;&lt; next_node.val</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Deep-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Deep-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Deep Traversal&quot;&gt;&lt;/a&gt;Binary T
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Validate Binary Search Tree</title>
    <link href="http://jack0pan.github.io/2018/04/28/Validate-Binary-Search-Tree/"/>
    <id>http://jack0pan.github.io/2018/04/28/Validate-Binary-Search-Tree/</id>
    <published>2018-04-28T13:47:19.000Z</published>
    <updated>2018-05-05T02:47:39.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value</span><br><span class="line">             is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>验证一棵二叉树是否为二叉搜索树。</p><p>思路就是递归验证左子树和右子树是否都满足条件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :left, :right</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@left</span>, <span class="doctag">@right</span> = nil, nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Boolean&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_bst</span><span class="params">(root, l = <span class="literal">nil</span>, r = <span class="literal">nil</span>)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> root.<span class="literal">nil</span>?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> l &amp;&amp; l &gt; root.val</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> r &amp;&amp; r &lt; root.val</span><br><span class="line"></span><br><span class="line">  is_valid_bst(root.left, l, root.val - <span class="number">1</span>) &amp;&amp; is_valid_bst(root.right, root.val + <span class="number">1</span>, r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(logn)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;98-Validate-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#98-Validate-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;98. Validate Binary Search Tree&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Restore IP Addresses</title>
    <link href="http://jack0pan.github.io/2018/04/27/Restore-IP-Addresses/"/>
    <id>http://jack0pan.github.io/2018/04/27/Restore-IP-Addresses/</id>
    <published>2018-04-27T14:01:17.000Z</published>
    <updated>2018-05-05T02:31:44.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这题思路主要是用动态规划，没什么好说的。主要在于对IP的每一项的判断要筛掉以下情况：</p><ul><li>每一项的值不能大于255</li><li>不能以“0”开头（比如：01，00），这种可以通过先转成整数，再转成字符串，和原来比较是否相同。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restore_ip_addresses</span><span class="params">(s)</span></span></span><br><span class="line">  ips = []</span><br><span class="line">  ip = []</span><br><span class="line">  _restore(ips, ip, s, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> ips</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _restore<span class="params">(ips, ip, s, level)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> s.<span class="literal">nil</span>? <span class="keyword">or</span> s.empty?</span><br><span class="line">  <span class="keyword">if</span> level == <span class="number">4</span></span><br><span class="line">    p = s.to_i</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> p &gt; <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> p.to_s != s</span><br><span class="line">    ip.push(s)</span><br><span class="line">    ips.push(ip.join(<span class="string">'.'</span>))</span><br><span class="line">    ip.pop</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">3</span>.times.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> s.length &lt; (i + <span class="number">1</span>)</span><br><span class="line">      p = s[<span class="number">0</span>..i].to_i</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> p &gt; <span class="number">255</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> p.to_s != s[<span class="number">0</span>..i]</span><br><span class="line">      ip.push(s[<span class="number">0</span>..i])</span><br><span class="line">      _restore(ips, ip, s[(i+<span class="number">1</span>)..-<span class="number">1</span>], level + <span class="number">1</span>)</span><br><span class="line">      ip.pop</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>这题的时间和空间复杂度是固定的，都是<code>O(3^4)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;93-Restore-IP-Addresses&quot;&gt;&lt;a href=&quot;#93-Restore-IP-Addresses&quot; class=&quot;headerlink&quot; title=&quot;93. Restore IP Addresses&quot;&gt;&lt;/a&gt;93. Restore IP A
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="http://jack0pan.github.io/2018/04/26/Reverse-Linked-List/"/>
    <id>http://jack0pan.github.io/2018/04/26/Reverse-Linked-List/</id>
    <published>2018-04-26T13:44:32.000Z</published>
    <updated>2018-05-05T03:29:43.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h1><h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Reverse a singly linked list.</p><p>Hint:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>题目要求两种实现思路：迭代方式和递归方式。</p><h4 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h4><p>先创建一个临时节点，从头往后遍历链表，来一个节点就插入临时节点和第一个节点之间，这样遍历完后，链表就逆序了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iteratively implement</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span></span></span><br><span class="line">  dummy_head = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  p = head</span><br><span class="line">  <span class="keyword">while</span> p</span><br><span class="line">    n = p.<span class="keyword">next</span></span><br><span class="line">    p.<span class="keyword">next</span> = dummy_head.<span class="keyword">next</span></span><br><span class="line">    dummy_head.<span class="keyword">next</span> = p</span><br><span class="line">    p = n</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  dummy_head.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><p>递归结束条件是遍历到最后一个节点，直接返回。其他情况就是让下一个节点指向当前节点。中间要一直返回最后一个节点，递归完后，最后一个节点就变成第一个节点了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># recursively implement</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span></span></span><br><span class="line">  <span class="keyword">if</span> head.<span class="literal">nil</span>? <span class="keyword">or</span> head.<span class="keyword">next</span>.<span class="literal">nil</span>?</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    n = head.<span class="keyword">next</span></span><br><span class="line">    head.<span class="keyword">next</span> = <span class="literal">nil</span></span><br><span class="line">    rest = reverse_list(n)</span><br><span class="line">    n.<span class="keyword">next</span> = head</span><br><span class="line">    <span class="keyword">return</span> rest</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Reverse a linked list from position m to n. Do it in one-pass.</p><p>Note: 1 ≤ m ≤ n ≤ length of list.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这题解法就是，先找到m节点的位置，然后把m和n之间的节点插入m节点和它之前节点就行。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; m</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_between</span><span class="params">(head, m, n)</span></span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> head.<span class="literal">nil</span>?</span><br><span class="line">  dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  dummy.<span class="keyword">next</span> = head</span><br><span class="line">  m_prev, i = dummy, <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> m_prev.<span class="keyword">next</span></span><br><span class="line">    m_prev = m_prev.<span class="keyword">next</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> i &lt; m</span><br><span class="line">  m_node = m_prev.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">return</span> head <span class="keyword">if</span> m_node.<span class="literal">nil</span>?</span><br><span class="line">  c_node = m_node.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> c_node</span><br><span class="line">    t = c_node.<span class="keyword">next</span></span><br><span class="line">    c_node.<span class="keyword">next</span> = m_prev.<span class="keyword">next</span></span><br><span class="line">    m_prev.<span class="keyword">next</span> = c_node</span><br><span class="line">    c_node = t</span><br><span class="line">    m_node.<span class="keyword">next</span> = c_node</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Linked List&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Decode Ways</title>
    <link href="http://jack0pan.github.io/2018/04/25/Decode-Ways/"/>
    <id>http://jack0pan.github.io/2018/04/25/Decode-Ways/</id>
    <published>2018-04-25T14:06:22.000Z</published>
    <updated>2018-05-06T03:35:25.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h1><h2 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure></p><p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们用<code>dp[i]</code>表示以第i个数字结尾的子串编码数量，计算公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] += dp[i-1] 如果s[i-1] &gt; 0</span><br><span class="line">dp[i] += dp[i-2] 如果10 &lt;= s[i-2]s[i-1] &lt;= 26</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_decodings</span><span class="params">(s)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> s.<span class="literal">nil</span>? <span class="keyword">or</span> s.empty? <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span></span><br><span class="line">  dp = Array.new(s.length + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  (<span class="number">2</span>..s.length).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    dp[i] += dp[i - <span class="number">1</span>] <span class="keyword">if</span> s[i - <span class="number">1</span>].to_i &gt; <span class="number">0</span></span><br><span class="line">    dp[i] += dp[i - <span class="number">2</span>] <span class="keyword">if</span> s[i - <span class="number">2</span>.. i - <span class="number">1</span>].to_i &gt;= <span class="number">10</span> <span class="keyword">and</span> s[i - <span class="number">2</span>.. i - <span class="number">1</span>].to_i &lt;= <span class="number">26</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  dp[s.length]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Decode-Ways&quot;&gt;&lt;a href=&quot;#Decode-Ways&quot; class=&quot;headerlink&quot; title=&quot;Decode Ways&quot;&gt;&lt;/a&gt;Decode Ways&lt;/h1&gt;&lt;h2 id=&quot;91-Decode-Ways&quot;&gt;&lt;a href=&quot;#91-
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Subsets</title>
    <link href="http://jack0pan.github.io/2018/04/24/Subsets/"/>
    <id>http://jack0pan.github.io/2018/04/24/Subsets/</id>
    <published>2018-04-24T13:56:24.000Z</published>
    <updated>2018-05-06T03:37:25.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h1><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>利用深度优先算法，把所有组合情况都遍历一遍。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  path, result = [], []</span><br><span class="line">  _subsets(nums, <span class="number">0</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _subsets<span class="params">(nums, index, path, result)</span></span></span><br><span class="line">  result.push(path.dup)</span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length</span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    _subsets(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">    path.pop</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul><h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>这道题和<a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Subsets</a>的区别在于去掉重复元素，最直接的办法就是在添加一种新组合前，判断一下是否已经含有这种组合。但是，这种做法增加了时间复杂度，LeetCode上的运行时间是<code>100ms</code>。</p><p>还有一种更有效的办法，在把元素添加到组合中，直接跳过重复元素。这种做法可以把时间缩短到<code>40ms</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; nums</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets_with_dup</span><span class="params">(nums)</span></span></span><br><span class="line">  nums.sort!</span><br><span class="line">  path, result = [], []</span><br><span class="line">  _subsets(nums, <span class="number">0</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _subsets<span class="params">(nums, index, path, result)</span></span></span><br><span class="line">  result.push(path.dup)</span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt; nums.length</span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    _subsets(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">    path.pop</span><br><span class="line">    i += <span class="number">1</span> <span class="keyword">while</span> i &lt; nums.length - <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Subsets&quot;&gt;&lt;a href=&quot;#Subsets&quot; class=&quot;headerlink&quot; title=&quot;Subsets&quot;&gt;&lt;/a&gt;Subsets&lt;/h1&gt;&lt;h2 id=&quot;78-Subsets&quot;&gt;&lt;a href=&quot;#78-Subsets&quot; class=&quot;head
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Gray Code</title>
    <link href="http://jack0pan.github.io/2018/04/23/Gray-Code/"/>
    <id>http://jack0pan.github.io/2018/04/23/Gray-Code/</id>
    <published>2018-04-23T14:01:20.000Z</published>
    <updated>2018-05-12T14:57:40.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure></p><p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p><p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p><p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>题目让生成格雷码，要生成n的格雷码，总共有2的n次方个，第i个生成方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &gt;&gt; 1) ^ i</span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray_code</span><span class="params">(n)</span></span></span><br><span class="line">  i, total, result = <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n, []</span><br><span class="line">  total.times.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    result.push((i <span class="meta">&gt;&gt; </span><span class="number">1</span>) ^ i)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(2^n)</code></li><li>空间复杂度：<code>O(2^n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;89-Gray-Code&quot;&gt;&lt;a href=&quot;#89-Gray-Code&quot; class=&quot;headerlink&quot; title=&quot;89. Gray Code&quot;&gt;&lt;/a&gt;89. Gray Code&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Partition List</title>
    <link href="http://jack0pan.github.io/2018/04/20/Partition-List/"/>
    <id>http://jack0pan.github.io/2018/04/20/Partition-List/</id>
    <published>2018-04-20T14:05:10.000Z</published>
    <updated>2018-05-14T15:37:25.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>方法就是从头到尾遍历链表，把小于给定值的节点从当前链表摘除，添加到新链表中。然后把链表添加到新链表尾部即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode</span></span><br><span class="line"><span class="comment">#     attr_accessor :val, :next</span></span><br><span class="line"><span class="comment">#     def initialize(val)</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@val</span> = val</span></span><br><span class="line"><span class="comment">#         <span class="doctag">@next</span> = nil</span></span><br><span class="line"><span class="comment">#     end</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;ListNode&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(head, x)</span></span></span><br><span class="line">  dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  new_dummy = ListNode.new(<span class="number">0</span>)</span><br><span class="line">  dummy.<span class="keyword">next</span> = head</span><br><span class="line">  cur, new_cur = dummy, new_dummy</span><br><span class="line">  <span class="keyword">while</span> cur.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">if</span> cur.<span class="keyword">next</span>.val &lt; x</span><br><span class="line">      new_cur.<span class="keyword">next</span> = cur.<span class="keyword">next</span></span><br><span class="line">      new_cur = new_cur.<span class="keyword">next</span></span><br><span class="line">      cur.<span class="keyword">next</span> = cur.<span class="keyword">next</span>.<span class="keyword">next</span></span><br><span class="line">      new_cur.<span class="keyword">next</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cur = cur.<span class="keyword">next</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  new_cur.<span class="keyword">next</span> = dummy.<span class="keyword">next</span></span><br><span class="line">  <span class="keyword">return</span> new_dummy.<span class="keyword">next</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;86-Partition-List&quot;&gt;&lt;a href=&quot;#86-Partition-List&quot; class=&quot;headerlink&quot; title=&quot;86. Partition List&quot;&gt;&lt;/a&gt;86. Partition List&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Combinations</title>
    <link href="http://jack0pan.github.io/2018/04/08/Combinations/"/>
    <id>http://jack0pan.github.io/2018/04/08/Combinations/</id>
    <published>2018-04-08T14:11:33.000Z</published>
    <updated>2018-05-16T15:20:50.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这题没啥好解释的，用深度优先搜索来解就行了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; n</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; k</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer[][]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(n, k)</span></span></span><br><span class="line">  path, result = [], []</span><br><span class="line">  _combine(n, k, <span class="number">1</span>, path, result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> _combine<span class="params">(n, k, start, path, result)</span></span></span><br><span class="line">  <span class="keyword">if</span> path.size == k</span><br><span class="line">    new_path = path.dup</span><br><span class="line">    result.push(new_path)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    i = start</span><br><span class="line">    <span class="keyword">while</span> i &lt;= n</span><br><span class="line">      path.push(i);</span><br><span class="line">      _combine(n, k, i + <span class="number">1</span>, path, result)</span><br><span class="line">      path.pop</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n!)</code></li><li>空间复杂度：<code>O(n!)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;77-Combinations&quot;&gt;&lt;a href=&quot;#77-Combinations&quot; class=&quot;headerlink&quot; title=&quot;77. Combinations&quot;&gt;&lt;/a&gt;77. Combinations&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Letter Combinations of a Phone Number</title>
    <link href="http://jack0pan.github.io/2018/03/06/Letter-Combinations-of-a-Phone-Number/"/>
    <id>http://jack0pan.github.io/2018/03/06/Letter-Combinations-of-a-Phone-Number/</id>
    <published>2018-03-06T13:53:17.000Z</published>
    <updated>2018-08-27T14:04:39.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="Telephone-keypad2"></p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure></p><p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>主思路是用递归解决：</p><ul><li>当n = 1时，返回数组对应的所有字母；</li><li>当n &gt; 1时，在n - 1的结果上加上第n个数字对应的字母。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; digits</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letter_combinations</span><span class="params">(digits)</span></span></span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> digits.length == <span class="number">0</span></span><br><span class="line">  h = [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">  <span class="keyword">if</span> digits.length == <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> h[digits[<span class="number">0</span>].to_i - <span class="number">2</span>].chars</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    comb = Array.new</span><br><span class="line">    previous = letter_combinations(digits[<span class="number">0</span>..-<span class="number">2</span>])</span><br><span class="line">    h[digits[-<span class="number">1</span>].to_i - <span class="number">2</span>].chars.each <span class="keyword">do</span> <span class="params">|char|</span></span><br><span class="line">      previous.map&#123; <span class="params">|p|</span> comb.push(p + char) &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> comb</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(3^n)</code></li><li>空间复杂度：<code>O(3^n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;17-Letter-Combinations-of-a-Phone-Number&quot;&gt;&lt;a href=&quot;#17-Letter-Combinations-of-a-Phone-Number&quot; class=&quot;headerlink&quot; title=&quot;17. Letter C
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Integer and Roman</title>
    <link href="http://jack0pan.github.io/2018/03/05/Interger-and-Roman/"/>
    <id>http://jack0pan.github.io/2018/03/05/Interger-and-Roman/</id>
    <published>2018-03-05T14:13:22.000Z</published>
    <updated>2018-08-26T02:54:35.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Integer-and-Roman"><a href="#Integer-and-Roman" class="headerlink" title="Integer and Roman"></a>Integer and Roman</h1><h2 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>先生成十进制数和罗马数的对应表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">romans = [&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;]</span><br><span class="line">values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</span><br></pre></td></tr></table></figure></p><p>拿到给定的数字后，就去遍历<code>values</code>，如果给定的数字比<code>values</code>当前的元素大，就减去当前元素。一直这样循环直到变为0。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; num</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_to_roman</span><span class="params">(num)</span></span></span><br><span class="line">  romans = [<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>]</span><br><span class="line">  values = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  str = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> num != <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &gt;= values[index]</span><br><span class="line">      num -= values[index]</span><br><span class="line">      str += romans[index]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code>，对应表的长度是固定的，主要看给定的数字大小；</li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>先构造对应表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &apos;I&apos; =&gt; 1, &apos;V&apos; =&gt; 5, &apos;X&apos; =&gt; 10, &apos;L&apos; =&gt; 50, &apos;C&apos; =&gt; 100, &apos;D&apos; =&gt; 500, &apos;M&apos; =&gt; 1000 &#125;</span><br></pre></td></tr></table></figure></p><p>遍历给定罗马数，要判断两种情况：</p><ul><li>当前值比前一个值大，那就先减去前一个值，再加上当前值与前一个值的差；</li><li>当前值小于等于前一个值，直接加上当前值。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roman_to_int</span><span class="params">(s)</span></span></span><br><span class="line">  t = &#123; <span class="string">'I'</span> =&gt; <span class="number">1</span>, <span class="string">'V'</span> =&gt; <span class="number">5</span>, <span class="string">'X'</span> =&gt; <span class="number">10</span>, <span class="string">'L'</span> =&gt; <span class="number">50</span>, <span class="string">'C'</span> =&gt; <span class="number">100</span>, <span class="string">'D'</span> =&gt; <span class="number">500</span>, <span class="string">'M'</span> =&gt; <span class="number">1000</span> &#125;</span><br><span class="line">  total = t[s[<span class="number">0</span>]]</span><br><span class="line">  i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; s.length</span><br><span class="line">    cur = t[s[i]]</span><br><span class="line">    pre = t[s[i - <span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">if</span> cur &gt; pre</span><br><span class="line">      total = total - pre + cur - pre</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      total += cur</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  total</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code>，n为罗马数字的长度</li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Integer-and-Roman&quot;&gt;&lt;a href=&quot;#Integer-and-Roman&quot; class=&quot;headerlink&quot; title=&quot;Integer and Roman&quot;&gt;&lt;/a&gt;Integer and Roman&lt;/h1&gt;&lt;h2 id=&quot;12-In
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Container With Most Water</title>
    <link href="http://jack0pan.github.io/2018/03/04/Container-With-Moster-Water/"/>
    <id>http://jack0pan.github.io/2018/03/04/Container-With-Moster-Water/</id>
    <published>2018-03-04T13:57:49.000Z</published>
    <updated>2018-08-25T15:13:13.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="question_11"></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>用左右两个指针分别指向首和尾，用较矮的高度乘以宽度，得到容量，判断是否比之前的大。</p><p>指针移动有两种情况：</p><ul><li>左指针对应的高度较矮，就把左指针右移；</li><li>右指针对应的高度较矮，就把右指针左移。</li></ul><p>就这样循环，直到两个指针相遇。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer[]&#125; height</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_area</span><span class="params">(height)</span></span></span><br><span class="line">  max, left, right = <span class="number">0</span>, <span class="number">0</span>, height.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> left &lt; right</span><br><span class="line">    max = [max, [height[left], height[right]].min * (right - left)].max</span><br><span class="line">    <span class="keyword">if</span> height[left] &lt; height[right]</span><br><span class="line">      left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;11-Container-With-Most-Water&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water&quot; class=&quot;headerlink&quot; title=&quot;11. Container With Most Water&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Number</title>
    <link href="http://jack0pan.github.io/2018/03/03/Palindrome-Number/"/>
    <id>http://jack0pan.github.io/2018/03/03/Palindrome-Number/</id>
    <published>2018-03-03T14:01:03.000Z</published>
    <updated>2018-08-19T12:25:49.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>Coud you solve it without converting the integer to a string?</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>思路是把给的数分成两半，判断两半是否相等。会有两种情况：</p><ul><li>数字位数是偶数，判断两部分是否相等</li><li>数字位数是奇数，将数值大的一半除以10后比较</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; x</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Boolean&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>)</span><br><span class="line">  r = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> x &gt; r</span><br><span class="line">    x, mod = x.divmod(<span class="number">10</span>)</span><br><span class="line">    r = r * <span class="number">10</span> + mod</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  x == r <span class="keyword">or</span> x == r / <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)，n是数字的位数</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9-Palindrome-Number&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number&quot;&gt;&lt;/a&gt;9. Palindrome Number&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>ZigZag Conversion</title>
    <link href="http://jack0pan.github.io/2018/03/02/ZigZag-Conversion/"/>
    <id>http://jack0pan.github.io/2018/03/02/ZigZag-Conversion/</id>
    <published>2018-03-02T14:02:47.000Z</published>
    <updated>2018-05-30T14:23:53.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我们先看一个具体的例子来找规律：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Explanation:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><p>我们把每个字符换成它所在行的坐标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0     0    0</span><br><span class="line">1   1 1  1 1</span><br><span class="line">2 2   2 2</span><br><span class="line">3     3</span><br></pre></td></tr></table></figure></p><p>恢复成原始的样子：<code>01232101232101</code>，规律很明显了。所以我们把每个字母放到对应的行上，最后把每行合并即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;Integer&#125; num_rows</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(s, num_rows)</span></span></span><br><span class="line">  <span class="keyword">return</span> s <span class="keyword">if</span> num_rows == <span class="number">1</span> <span class="params">||</span> num_rows &gt;= s.length</span><br><span class="line">  characters = Array.new(num_rows) &#123; <span class="string">''</span> &#125;</span><br><span class="line">  index, step = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  s.chars.each <span class="keyword">do</span> <span class="params">|character|</span></span><br><span class="line">    characters[index] += character</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elsif</span> index == num_rows - <span class="number">1</span></span><br><span class="line">      step = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    index += step</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  characters.join</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-ZigZag-Conversion&quot;&gt;&lt;a href=&quot;#6-ZigZag-Conversion&quot; class=&quot;headerlink&quot; title=&quot;6. ZigZag Conversion&quot;&gt;&lt;/a&gt;6. ZigZag Conversion&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>String to Integer (atoi)</title>
    <link href="http://jack0pan.github.io/2018/03/02/String-to-Integer-atoi/"/>
    <id>http://jack0pan.github.io/2018/03/02/String-to-Integer-atoi/</id>
    <published>2018-03-02T13:56:03.000Z</published>
    <updated>2018-06-14T13:13:07.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><ul><li>Only the space character ‘ ‘ is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li></ul><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大体上分为三个步骤：</p><ul><li>先判断正负号，并去掉空格之类的字符</li><li>将字符串按字节遍历，把每个字节对应的数字算出来，并把总数乘10加上这个数</li><li>最后要判断是否溢出</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; str</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_atoi</span><span class="params">(str)</span></span></span><br><span class="line">  str.strip!</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> str.<span class="literal">nil</span>? <span class="keyword">or</span> str.length == <span class="number">0</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">"-"</span></span><br><span class="line">    cs, s = str[<span class="number">1</span>..-<span class="number">1</span>], -<span class="number">1</span></span><br><span class="line">  <span class="keyword">elsif</span> str[<span class="number">0</span>] == <span class="string">"+"</span></span><br><span class="line">    cs, s = str[<span class="number">1</span>..-<span class="number">1</span>], <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cs, s = str, <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> cs.<span class="literal">nil</span>?</span><br><span class="line">  cs.each_byte <span class="keyword">do</span> <span class="params">|b|</span></span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">48</span> <span class="keyword">and</span> b &lt;= <span class="number">57</span></span><br><span class="line">      i = i * <span class="number">10</span> + (b - <span class="number">48</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  i = s * i</span><br><span class="line">  <span class="keyword">if</span> i &lt; -<span class="number">2147483648</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2147483648</span></span><br><span class="line">  <span class="keyword">elsif</span> i &gt; <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;8-String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#8-String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot;8. String to Integer (atoi)&quot;&gt;&lt;/a&gt;8. String t
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Longest Series</title>
    <link href="http://jack0pan.github.io/2018/02/24/Longest-Series/"/>
    <id>http://jack0pan.github.io/2018/02/24/Longest-Series/</id>
    <published>2018-02-24T14:01:19.000Z</published>
    <updated>2018-05-27T01:38:33.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Longest-Series"><a href="#Longest-Series" class="headerlink" title="Longest Series"></a>Longest Series</h1><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Examples:</p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>计算没有重复字母的最长子串。把遍历过的字母都存入hash中，value就是它们的索引值。</p><p>在后面的遍历中如果遇到hash中存在的字符，说明子串已经找出来了，计算长度，并判断是否比存的最大值大。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;Integer&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span><span class="params">(s)</span></span></span><br><span class="line">  max = <span class="number">0</span></span><br><span class="line">  start = <span class="number">0</span></span><br><span class="line">  hash = Hash.new(-<span class="number">1</span>)</span><br><span class="line">  s.chars.each_with_index <span class="keyword">do</span> <span class="params">|char, i|</span></span><br><span class="line">    start = start &gt; hash[char] + <span class="number">1</span> ? start : hash[char] + <span class="number">1</span></span><br><span class="line">    hash[char] = i</span><br><span class="line">    max = max &gt; i - start + <span class="number">1</span> ? max : i - start + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  max</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>以每个元素为中心点，往左右两侧找回文串。</p><p>要考虑奇数回文串和偶数回文串，所以中心点分1个和2个两种情况。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_palindrome</span><span class="params">(s, left, right)</span></span></span><br><span class="line">  n = s.length</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= n-<span class="number">1</span> &amp;&amp; s[left] == s[right])</span><br><span class="line">    left -= <span class="number">1</span></span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  s[(left + <span class="number">1</span>)..(right - <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String&#125; s</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_palindrome</span><span class="params">(s)</span></span></span><br><span class="line">  i, n = <span class="number">0</span>, s.length</span><br><span class="line">  <span class="keyword">return</span> s <span class="keyword">if</span> n &lt;= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  longest = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; n - <span class="number">1</span></span><br><span class="line">    str = find_palindrome(s, i, i)</span><br><span class="line">    longest = str <span class="keyword">if</span> str.length &gt; longest.length</span><br><span class="line">    str = find_palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">    longest = str <span class="keyword">if</span> str.length &gt; longest.length</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  longest</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All given inputs are in lowercase letters a-z.</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>从数组中找出长度最短的字符串，假设最短字符串就是最长前缀，把数组遍历一遍，查看是否满足。</p><p>不满足就把最短字符串去掉最后一个字符，继续遍历，直到找到满足情况的子串。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">@param</span> &#123;String[]&#125; strs</span></span><br><span class="line"><span class="comment"># <span class="doctag">@return</span> &#123;String&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_common_prefix</span><span class="params">(strs)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> strs.length == <span class="number">0</span></span><br><span class="line">  min_size = <span class="number">10000</span></span><br><span class="line">  min_index = -<span class="number">1</span></span><br><span class="line">  strs.each_with_index <span class="keyword">do</span> <span class="params">|str, index|</span></span><br><span class="line">    <span class="keyword">if</span> str.length &lt; min_size</span><br><span class="line">      min_size = str.length</span><br><span class="line">      min_index = index</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  i = min_size - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &gt;= <span class="number">0</span></span><br><span class="line">    prefix = strs[min_index][<span class="number">0</span>..i]</span><br><span class="line">    found = <span class="literal">true</span></span><br><span class="line">    strs.each_with_index <span class="keyword">do</span> <span class="params">|str, index|</span></span><br><span class="line">      <span class="keyword">next</span> <span class="keyword">if</span> index == min_index</span><br><span class="line">      <span class="keyword">if</span> prefix != str[<span class="number">0</span>..i]</span><br><span class="line">        found = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> prefix <span class="keyword">if</span> found</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：<code>O(m * n)</code>，m是最短子串的长度，n是数组长度。</li><li>空间复杂度：<code>O(m)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Longest-Series&quot;&gt;&lt;a href=&quot;#Longest-Series&quot; class=&quot;headerlink&quot; title=&quot;Longest Series&quot;&gt;&lt;/a&gt;Longest Series&lt;/h1&gt;&lt;h2 id=&quot;3-Longest-Substri
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://jack0pan.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
